
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-8.5.10">
    
    
      
        <title>编写测试 - 我的rust学习示例APPS</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.975780f9.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.2505c338.min.css">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="None" data-md-color-accent="None">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href=".." title="我的rust学习示例APPS" class="md-header__button md-logo" aria-label="我的rust学习示例APPS" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            我的rust学习示例APPS
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              编写测试
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="我的rust学习示例APPS" class="md-nav__button md-logo" aria-label="我的rust学习示例APPS" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    我的rust学习示例APPS
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        简介
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../hello-world/" class="md-nav__link">
        hello world
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../hello-cargo/" class="md-nav__link">
        Hello Cargo
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../guessing-game/" class="md-nav__link">
        猜数游戏
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../common-programing-concepts/" class="md-nav__link">
        常见编程概念
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../ownership/" class="md-nav__link">
        所有权
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../struct/" class="md-nav__link">
        结构体
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../enumerations/" class="md-nav__link">
        枚举
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../packages/" class="md-nav__link">
        包、crate、模块
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../common-collections/" class="md-nav__link">
        常见集合
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../error-handing/" class="md-nav__link">
        错误处理
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../generics/" class="md-nav__link">
        泛型/Trait/生命周期
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          编写测试
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        编写测试
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    如何编写
  </a>
  
    <nav class="md-nav" aria-label="如何编写">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    测试函数剖析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assert" class="md-nav__link">
    assert!宏
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assert_eqassert_ne" class="md-nav__link">
    assert_eq!和assert_ne!宏
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    自定义失败信息
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#panic" class="md-nav__link">
    panic检测
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resultt-e" class="md-nav__link">
    Result&lt;T, E>测试
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    控制如何运行
  </a>
  
    <nav class="md-nav" aria-label="控制如何运行">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    并行或连续测试
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    显示函数输出
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    指定名称运行部分测试
  </a>
  
    <nav class="md-nav" aria-label="指定名称运行部分测试">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    单个测试
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    过滤运行多个测试
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    忽略某些测试
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    测试的组织结构
  </a>
  
    <nav class="md-nav" aria-label="测试的组织结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    单元测试
  </a>
  
    <nav class="md-nav" aria-label="单元测试">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cfgtest" class="md-nav__link">
    测试模块和 #[cfg(test)]
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    测试私有函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    集成测试
  </a>
  
    <nav class="md-nav" aria-label="集成测试">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tests" class="md-nav__link">
    tests 目录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    集成测试中的子模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#crate" class="md-nav__link">
    二进制 crate 的集成测试
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    总结
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../an-io-project/" class="md-nav__link">
        构建一个命令行程序
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../closures/" class="md-nav__link">
        迭代器与闭包
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../more-about-cargo/" class="md-nav__link">
        Cargo 和 Cargo.io
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    如何编写
  </a>
  
    <nav class="md-nav" aria-label="如何编写">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    测试函数剖析
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assert" class="md-nav__link">
    assert!宏
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assert_eqassert_ne" class="md-nav__link">
    assert_eq!和assert_ne!宏
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    自定义失败信息
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#panic" class="md-nav__link">
    panic检测
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resultt-e" class="md-nav__link">
    Result&lt;T, E>测试
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    控制如何运行
  </a>
  
    <nav class="md-nav" aria-label="控制如何运行">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    并行或连续测试
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    显示函数输出
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    指定名称运行部分测试
  </a>
  
    <nav class="md-nav" aria-label="指定名称运行部分测试">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    单个测试
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    过滤运行多个测试
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    忽略某些测试
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    测试的组织结构
  </a>
  
    <nav class="md-nav" aria-label="测试的组织结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    单元测试
  </a>
  
    <nav class="md-nav" aria-label="单元测试">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cfgtest" class="md-nav__link">
    测试模块和 #[cfg(test)]
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    测试私有函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    集成测试
  </a>
  
    <nav class="md-nav" aria-label="集成测试">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tests" class="md-nav__link">
    tests 目录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    集成测试中的子模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#crate" class="md-nav__link">
    二进制 crate 的集成测试
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    总结
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="_1">编写测试</h1>
<p>Edsger W. Dijkstra 在其 1972 年的文章【谦卑的程序员】（“The Humble Programmer”）中说到 “软件测试可能是显示错误存在的一种非常有效的方法，但对于显示错误的(测试)存在却远远不够。”（“Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.”）这并不意味着我们不该尽可能地测试软件！</p>
<p>程序的正确性意味着代码如我们期望的那样运行。Rust 是一个相当注重正确性的编程语言，不过正确性是一个难以证明的复杂主题。Rust 的类型系统在此问题上下了很大的功夫，不过它不可能捕获所有种类的错误。为此，<strong>Rust 也在语言本身包含了编写软件测试的支持。</strong></p>
<p>例如，我们可以编写一个叫做 <code>add_two</code> 的函数，作用是将传递给它的值加二的函数。它的签名有一个整型参数并返回一个整型值。当实现和编译这个函数时，Rust 会进行所有目前我们已经见过的类型检查和借用检查，例如，这些检查会确保我们不会传递 <strong>String</strong> 或无效的引用给这个函数。Rust 所 <strong>不能</strong> 检查的是这个函数是否会准确的完成我们期望的工作：返回参数加二后的值，而不是比如说参数加 10 或减 50 的值！这也就是测试出场的地方。</p>
<p>我们可以编写测试断言，比如说，当传递 <code>3</code> 给 <code>add_two</code> 函数时，返回值是 <code>5</code>。<strong>无论何时对代码进行修改，都可以运行测试来确保任何现存的正确行为没有被改变。</strong></p>
<p>测试是一项复杂的技能：虽然不能在一个章节的篇幅中介绍如何编写好的测试的每个细节，但我们还是会讨论 Rust 测试功能的机制。我们会讲到编写测试时会用到的注解和宏，运行测试的默认行为和选项，以及如何将测试组织成单元测试和集成测试。</p>
<h2 id="_2">如何编写</h2>
<p>Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作：</p>
<ul>
<li><strong>设置任何所需的数据或状态</strong></li>
<li><strong>运行需要测试的代码</strong></li>
<li><strong>断言其结果是我们所期望的</strong></li>
</ul>
<p>Rust 提供的专门用来编写测试的功能：<strong>test</strong> 属性、一些<strong>宏</strong>和 <strong>should_panic</strong> 属性。</p>
<h3 id="_3">测试函数剖析</h3>
<p>作为最简单例子，Rust 中的测试就是一个带有 <strong>test</strong> 属性注解的函数。<strong>属性</strong>（attribute）是关于 Rust 代码片段的元数据；第五章中结构体中用到的 <strong>derive</strong> 属性就是一个例子。为了将一个函数变成测试函数，需要在 <strong>fn</strong> 行之前加上 <strong>#[test]</strong>。当使用 <code>cargo test</code> 命令运行测试时，Rust 会构建一个测试执行程序用来调用标记了 <strong>test</strong> 属性的函数，并报告每一个测试是通过还是失败。</p>
<p>第七章当使用 <strong>Cargo</strong> 新建一个库项目时，它会自动为我们生成一个测试模块和一个测试函数。这有助于我们开始编写测试，因为这样每次开始新项目时不必去查找测试函数的具体结构和语法了。当然你也可以额外增加任意多的测试函数以及测试模块！</p>
<p>我们会通过实验那些自动生成的测试模版而不是实际编写测试代码来探索测试如何工作的一些方面。接着，我们会写一些真正的测试，调用我们编写的代码并断言他们的行为的正确性。</p>
<p>让我们创建一个新的库项目 <strong>adder</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="cp">$</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="o">--</span><span class="n">lib</span><span class="w"></span>
<span class="w">     </span><span class="n">Created</span><span class="w"> </span><span class="n">library</span><span class="w"> </span><span class="err">`</span><span class="n">adder</span><span class="err">`</span><span class="w"> </span><span class="n">project</span><span class="w"></span>
<span class="cp">$</span><span class="w"> </span><span class="n">cd</span><span class="w"> </span><span class="n">adder</span><span class="w"></span>
</code></pre></div>
<p><strong>adder</strong> 库中 <strong>src/lib.rs</strong> 的内容应该看起来如示例所示：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 由 cargo new 自动生成的测试模块和函数</span>

<span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">it_works</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>现在让我们暂时忽略 <strong>tests</strong> 模块和 <strong>#[cfg(test)]</strong> 注解，并只关注函数来了解其如何工作。注意 <strong>fn</strong> 行之前的 <strong>#[test]</strong>：<ins class="critic">这个属性表明这是一个测试函数，这样测试执行者就知道将其作为测试处理</ins>。因为也可以在 <strong>tests</strong> 模块中拥有非测试的函数来帮助我们建立通用场景或进行常见操作，所以需要使用 <strong>#[test]</strong> 属性标明哪些函数是测试。</p>
<p>函数体通过使用 <strong>assert_eq!</strong> 宏来断言 <code>2</code> 加 <code>2</code> 等于 <code>4</code>。一个典型的测试的格式，就是像这个例子中的断言一样。接下来运行就可以看到测试通过。</p>
<p><code>cargo test</code> 命令会运行项目中所有的测试，如示例所示：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 运行自动生成测试的输出</span>

$ cargo <span class="nb">test</span>
   Compiling adder v0.1.0 <span class="o">(</span>file:///projects/adder<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.57s
     Running unittests <span class="o">(</span>target/debug/deps/adder-92948b65e88960b4<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> tests::it_works ... ok

<span class="nb">test</span> result: ok. <span class="m">1</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

   Doc-tests adder

running <span class="m">0</span> tests

<span class="nb">test</span> result: ok. <span class="m">0</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s
</code></pre></div>
<p>Cargo 编译并运行了测试。在 <strong>Compiling</strong>、<strong>Finished</strong> 和 <strong>Running</strong> 这几行之后，可以看到 <strong>running 1 test</strong> 这一行。
下一行显示了生成的测试函数的名称，它是 <code>it_works</code>，以及测试的运行结果，<strong>ok</strong>。接着可以看到全体测试运行结果的摘要：<strong>test result: ok</strong>. 意味着所有测试都通过了。<strong>1 passed; 0 failed</strong> 表示通过或失败的测试数量。</p>
<p>因为之前我们并没有将任何测试标记为忽略，所以摘要中会显示 <strong>0 ignored</strong>。我们也没有过滤需要运行的测试，所以摘要中会显示<strong>0 filtered out</strong>。在下一部分 “<strong>控制测试如何运行</strong>” 会讨论忽略和过滤测试。</p>
<p><strong>0 measured</strong> 统计是针对性能测试的。<strong>性能测试</strong>（benchmark tests）在编写本书时，仍只能用于 Rust 开发版（nightly Rust）。请查看 <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">性能测试的文档</a> 了解更多。</p>
<p>测试输出中的以 <strong>Doc-tests adder</strong> 开头的这一部分是所有文档测试的结果。我们现在并没有任何文档测试，不过 Rust 会编译任何在 API 文档中的代码示例。这个功能帮助我们使文档和代码保持同步！在第十四章的 “<a href="https://kaisery.github.io/trpl-zh-cn/ch14-02-publishing-to-crates-io.html#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A%E4%BD%9C%E4%B8%BA%E6%B5%8B%E8%AF%95">文档注释作为测试</a>” 部分会讲到如何编写文档测试。现在我们将忽略 <strong>Doc-tests</strong> 部分的输出。</p>
<p>让我们改变测试的名称并看看这如何改变测试的输出。给 <strong>it_works</strong> 函数起个不同的名字，比如 <strong>exploration</strong>，像这样：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">exploration</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>并再次运行 <code>cargo test</code>。现在输出中将出现 <strong>exploration</strong> 而不是 <code>it_works</code>：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling adder v0.1.0 <span class="o">(</span>file:///projects/adder<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.59s
     Running unittests <span class="o">(</span>target/debug/deps/adder-92948b65e88960b4<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> tests::exploration ... ok

<span class="nb">test</span> result: ok. <span class="m">1</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

   Doc-tests adder

running <span class="m">0</span> tests

<span class="nb">test</span> result: ok. <span class="m">0</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s
</code></pre></div>
<p>让我们增加另一个测试，不过这一次是一个会失败的测试！当测试函数中出现 <code>panic</code> 时测试就失败了。每一个测试都在一个新线程中运行，当主线程发现测试线程异常了，就将对应测试标记为失败。第九章讲到了最简单的造成 <code>panic</code> 的方法：调用 <code>panic!</code> 宏。写入新测试 <code>another</code> 后， <strong>src/lib.rs</strong> 现在看起来如示例所示：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">exploration</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">another</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;Make this test fail&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>再次 <code>cargo test</code> 运行测试。输出应该看起来像示例，它表明 <strong>exploration</strong> 测试通过了而 <strong>another</strong> 失败了：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 一个测试通过和一个测试失败的测试结果</span>

$ cargo <span class="nb">test</span>
   Compiling adder v0.1.0 <span class="o">(</span>file:///projects/adder<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.72s
     Running unittests <span class="o">(</span>target/debug/deps/adder-92948b65e88960b4<span class="o">)</span>

running <span class="m">2</span> tests
<span class="nb">test</span> tests::another ... FAILED
<span class="nb">test</span> tests::exploration ... ok

failures:

---- tests::another stdout ----
thread <span class="s1">&#39;main&#39;</span> panicked at <span class="s1">&#39;Make this test fail&#39;</span>, src/lib.rs:10:9
note: run with <span class="sb">`</span><span class="nv">RUST_BACKTRACE</span><span class="o">=</span><span class="m">1</span><span class="sb">`</span> environment variable to display a backtrace


failures:
    tests::another

<span class="nb">test</span> result: FAILED. <span class="m">1</span> passed<span class="p">;</span> <span class="m">1</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

error: <span class="nb">test</span> failed, to rerun pass <span class="s1">&#39;--lib&#39;</span>
</code></pre></div>
<p><code>test tests::another</code> 这一行是 <strong>FAILED</strong> 而不是 <strong>ok</strong> 了。在单独测试结果和摘要之间多了两个新的部分：第一个部分显示了测试失败的详细原因。在这个例子中，<strong>another</strong> 因为在 <strong>src/lib.rs</strong> 的第 <strong>10</strong> 行 <strong>panicked at 'Make this test fail'</strong> 而失败。下一部分列出了所有失败的测试，这在有很多测试和很多失败测试的详细输出时很有帮助。我们可以通过使用失败测试的名称来只运行这个测试，以便调试；下一部分 “控制测试如何运行” 会讲到更多运行测试的方法。</p>
<p>最后是摘要行：总体上讲，测试结果是 <strong>FAILED</strong>。有一个测试通过和一个测试失败。</p>
<p>现在我们见过不同场景中测试结果是什么样子的了，再来看看除 <strong>panic!</strong> 之外的一些在测试中有帮助的宏吧。</p>
<h3 id="assert">assert!宏</h3>
<mark class="critic block">
<p><strong>assert!</strong> 宏由标准库提供，在希望确保测试中一些条件为 <strong>true</strong> 时非常有用。
需要向 <strong>assert!</strong> 宏提供一个求值为布尔值的参数。</p>
<ul>
<li>如果值是 <strong>true</strong>，<strong>assert!</strong> 什么也不做，同时测试会通过。</li>
<li>如果值为 <strong>false</strong>，<strong>assert!</strong> 调用 <strong>panic!</strong> 宏，这会导致测试失败。</li>
</ul>
<p><strong>assert!</strong> 宏帮助我们检查代码是否以期望的方式运行。</p>
</mark>
<p>回忆一下第五章中，示例中有一个 <strong>Rectangle</strong> 结构体和一个 <strong>can_hold</strong> 方法，在示例中再次使用他们。将他们放进 <strong>src/lib.rs</strong> 并使用 <strong>assert!</strong> 宏编写一些测试。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 第五章中 Rectangle 结构体和其 can_hold 方法</span>

<span class="cp">#[derive(Debug)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">width</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">height</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">can_hold</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rectangle</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">height</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><code>can_hold</code> 方法返回一个布尔值，这意味着它完美符合 <strong>assert!</strong> 宏的使用场景。在示例中，让我们编写一个 <strong>can_hold</strong> 方法的测试来作为练习，这里创建一个长为 8 宽为 7 的 <strong>Rectangle</strong> 实例，并假设它可以放得下另一个长为 5 宽为 1 的 <strong>Rectangle</strong> 实例：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 将测试命名为 larger_can_hold_smaller，</span>
<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">larger_can_hold_smaller</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// 并创建所需的两个 Rectangle 实例。</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">larger</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">width</span>: <span class="mi">8</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">height</span>: <span class="mi">7</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">smaller</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">width</span>: <span class="mi">5</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">height</span>: <span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="c1">// 接着调用 assert! 宏并传递 larger.can_hold(&amp;smaller) 调用的结果作为参数。</span>
<span class="w">        </span><span class="c1">// 这个表达式预期会返回 true，所以测试应该通过。</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">larger</span><span class="p">.</span><span class="n">can_hold</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smaller</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>注意在 <strong>tests</strong> 模块中新增加了一行：<code>use super::*;</code>。<strong>tests</strong> 是一个普通的模块，它遵循第七章 “<a href="https://kaisery.github.io/trpl-zh-cn/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">路径用于引用模块树中的项</a>” 部分介绍的可见性规则。因为这是一个内部模块，要测试外部模块中的代码，需要将其引入到内部模块的作用域中。这里选择使用 <strong>glob</strong> 全局导入，以便在 <strong>tests</strong> 模块中使用所有在外部模块定义的内容。</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling rectangle v0.1.0 <span class="o">(</span>file:///projects/rectangle<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.66s
     Running unittests <span class="o">(</span>target/debug/deps/rectangle-6584c4561e48942e<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> tests::larger_can_hold_smaller ... ok

<span class="nb">test</span> result: ok. <span class="m">1</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

   Doc-tests rectangle

running <span class="m">0</span> tests

<span class="nb">test</span> result: ok. <span class="m">0</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s
</code></pre></div>
<p>再来增加另一个测试，这一回断言一个更小的矩形不能放下一个更大的矩形：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">larger_can_hold_smaller</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// --snip--</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">smaller_cannot_hold_larger</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">larger</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">width</span>: <span class="mi">8</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">height</span>: <span class="mi">7</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">smaller</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">width</span>: <span class="mi">5</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">height</span>: <span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="c1">// 因为这里 can_hold 函数的正确结果是 false ，</span>
<span class="w">        </span><span class="c1">// 需要将这个结果取反后传递给 assert! 宏。</span>
<span class="w">        </span><span class="c1">// 因此 can_hold 返回 false 时测试就会通过：</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="o">!</span><span class="n">smaller</span><span class="p">.</span><span class="n">can_hold</span><span class="p">(</span><span class="o">&amp;</span><span class="n">larger</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling rectangle v0.1.0 <span class="o">(</span>file:///projects/rectangle<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.66s
     Running unittests <span class="o">(</span>target/debug/deps/rectangle-6584c4561e48942e<span class="o">)</span>

running <span class="m">2</span> tests
<span class="nb">test</span> tests::larger_can_hold_smaller ... ok
<span class="nb">test</span> tests::smaller_cannot_hold_larger ... ok

<span class="nb">test</span> result: ok. <span class="m">2</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

   Doc-tests rectangle

running <span class="m">0</span> tests

<span class="nb">test</span> result: ok. <span class="m">0</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s
</code></pre></div>
<p>两个通过的测试！现在看看如果引入一个 <strong>bug</strong> 的话测试结果会发生什么。将 <strong>can_hold</strong> 方法中比较长度时本应使用大于号的地方改成小于号：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// --snip--</span>
<span class="k">impl</span><span class="w"> </span><span class="n">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">can_hold</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rectangle</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">height</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>现在运行测试会产生：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling rectangle v0.1.0 <span class="o">(</span>file:///projects/rectangle<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.66s
     Running unittests <span class="o">(</span>target/debug/deps/rectangle-6584c4561e48942e<span class="o">)</span>

running <span class="m">2</span> tests
<span class="nb">test</span> tests::larger_can_hold_smaller ... FAILED
<span class="nb">test</span> tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread <span class="s1">&#39;main&#39;</span> panicked at <span class="s1">&#39;assertion failed: larger.can_hold(&amp;smaller)&#39;</span>, src/lib.rs:28:9
note: run with <span class="sb">`</span><span class="nv">RUST_BACKTRACE</span><span class="o">=</span><span class="m">1</span><span class="sb">`</span> environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

<span class="nb">test</span> result: FAILED. <span class="m">1</span> passed<span class="p">;</span> <span class="m">1</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

error: <span class="nb">test</span> failed, to rerun pass <span class="s1">&#39;--lib&#39;</span>
</code></pre></div>
<p>我们的测试捕获了 <strong>bug</strong>！因为 <strong>larger.length</strong> 是 8 而 <strong>smaller.length</strong> 是 5，<strong>can_hold</strong> 中的长度比较现在因为 8 不小于 5 而返回 <strong>false</strong>。</p>
<h3 id="assert_eqassert_ne">assert_eq!和assert_ne!宏</h3>
<mark class="critic block">
<p>测试功能的一个常用方法是将需要测试代码的值与期望值做比较，并检查是否相等。
可以通过向 <strong>assert!</strong> 宏传递一个使用 <strong>==</strong> 运算符的表达式来做到。
不过这个操作实在是太常见了，以至于标准库提供了一对宏来更方便的处理这些操作 —— <strong>assert_eq!</strong> 和 <strong>assert_ne!</strong>。这两个宏分别比较两个值是相等还是不相等。
当断言失败时他们也会打印出这两个值具体是什么，以便于观察测试 为什么 <strong>失败</strong>，而 <strong>assert!</strong> 只会打印出它从 <strong>==</strong> 表达式中得到了 <strong>false</strong> 值，而不是导致 <strong>false</strong> 的两个值。</p>
</mark>
<p>下面示例中，让我们编写一个对其参数加二并返回结果的函数 <code>add_two</code>。接着使用 <strong>assert_eq!</strong> 宏测试这个函数。</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add_two</span><span class="p">(</span><span class="n">a</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">it_adds_two</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// 测试通过了！</span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">add_two</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling adder v0.1.0 <span class="o">(</span>file:///projects/adder<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.58s
     Running unittests <span class="o">(</span>target/debug/deps/adder-92948b65e88960b4<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> tests::it_adds_two ... ok

<span class="nb">test</span> result: ok. <span class="m">1</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

   Doc-tests adder

running <span class="m">0</span> tests

<span class="nb">test</span> result: ok. <span class="m">0</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s
</code></pre></div>
<p>传递给 <strong>assert_eq!</strong> 宏的第一个参数 <code>4</code> ，等于调用 <code>add_two(2)</code> 的结果。测试中的这一行 <strong>test</strong> <strong>tests::it_adds_two ... ok</strong> 中 <strong>ok</strong> 表明测试通过！</p>
<p>在代码中引入一个 <strong>bug</strong> 来看看使用 <strong>assert_eq!</strong> 的测试失败是什么样的。修改 <strong>add_two</strong> 函数的实现使其加 3：</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add_two</span><span class="p">(</span><span class="n">a</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>再次运行测试：</p>
<div class="highlight"><pre><span></span><code><span class="cp">$</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="n">test</span><span class="w"></span>
<span class="w">   </span><span class="n">Compiling</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="n">v0</span><span class="p">.</span><span class="mf">1.0</span><span class="w"> </span><span class="p">(</span><span class="n">file</span>:<span class="sd">///projects/adder)</span>
<span class="w">    </span><span class="n">Finished</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="p">[</span><span class="n">unoptimized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">debuginfo</span><span class="p">]</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.61</span><span class="n">s</span><span class="w"></span>
<span class="w">     </span><span class="n">Running</span><span class="w"> </span><span class="n">unittests</span><span class="w"> </span><span class="p">(</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">deps</span><span class="o">/</span><span class="n">adder</span><span class="o">-</span><span class="mi">92948</span><span class="n">b65e88960b4</span><span class="p">)</span><span class="w"></span>

<span class="n">running</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">test</span><span class="w"></span>
<span class="n">test</span><span class="w"> </span><span class="n">tests</span>::<span class="n">it_adds_two</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="n">FAILED</span><span class="w"></span>

<span class="n">failures</span>:

<span class="o">----</span><span class="w"> </span><span class="n">tests</span>::<span class="n">it_adds_two</span><span class="w"> </span><span class="n">stdout</span><span class="w"> </span><span class="o">----</span><span class="w"></span>
<span class="n">thread</span><span class="w"> </span><span class="o">&#39;</span><span class="na">main</span><span class="o">&#39;</span><span class="w"> </span><span class="n">panicked</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="o">&#39;</span><span class="na">assertion</span><span class="w"> </span><span class="n">failed</span>: <span class="err">`</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="err">`</span><span class="w"></span>
<span class="w">  </span><span class="n">left</span>: <span class="err">`</span><span class="mi">4</span><span class="err">`</span><span class="p">,</span><span class="w"></span>
<span class="w"> </span><span class="n">right</span>: <span class="err">`</span><span class="mi">5</span><span class="err">`</span><span class="o">&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="o">/</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">11</span>:<span class="mi">9</span><span class="w"></span>
<span class="n">note</span>: <span class="nc">run</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="err">`</span><span class="n">RUST_BACKTRACE</span><span class="o">=</span><span class="mi">1</span><span class="err">`</span><span class="w"> </span><span class="n">environment</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">display</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">backtrace</span><span class="w"></span>


<span class="n">failures</span>:
    <span class="nc">tests</span>::<span class="n">it_adds_two</span><span class="w"></span>

<span class="n">test</span><span class="w"> </span><span class="n">result</span>: <span class="nc">FAILED</span><span class="p">.</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">passed</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">failed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">ignored</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">measured</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">filtered</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.00</span><span class="n">s</span><span class="w"></span>

<span class="n">error</span>: <span class="nc">test</span><span class="w"> </span><span class="n">failed</span><span class="p">,</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">rerun</span><span class="w"> </span><span class="n">pass</span><span class="w"> </span><span class="o">&#39;--</span><span class="n">lib</span><span class="o">&#39;</span><span class="w"></span>
</code></pre></div>
<p>测试捕获到了 <strong>bug</strong>！<strong>it_adds_two</strong> 测试失败，显示信息 <strong>assertion failed: `(left == right)`</strong> 并表明 <strong>left</strong> 是 4 而 <strong>right</strong> 是 5。
这个信息有助于我们开始调试：它说 <strong>assert_eq!</strong> 的 left 参数是 4，而 right 参数，也就是 add_two(2) 的结果，是 5。</p>
<p>需要注意的是，在一些语言和测试框架中，断言两个值相等的函数的参数叫做 <strong>expected</strong> 和 <strong>actual</strong>，而且指定参数的顺序是很关键的。然而在 Rust 中，他们则叫做 <strong>left</strong> 和 <strong>right</strong>，同时指定期望的值和被测试代码产生的值的顺序并不重要。这个测试中的断言也可以写成 <strong>assert_eq!(add_two(2), 4)</strong>，这时失败信息会变成 <strong>assertion failed: `(left == right)`</strong> 其中 left 是 5 而 right 是 4。</p>
<p><strong>assert_ne!</strong> 宏在传递给它的两个值不相等时通过，而在相等时失败。在代码按预期运行，我们不确定值 <strong>会</strong> 是什么，不过能确定值绝对 <strong>不会</strong> 是什么的时候，这个宏最有用处。例如，如果一个函数保证会以某种方式改变其输出，不过这种改变方式是由运行测试时是星期几来决定的，这时最好的断言可能就是函数的输出不等于其输入。</p>
<ins class="critic block">
<p><strong>assert_eq!</strong> 和 <strong>assert_ne!</strong> 宏在底层分别使用了 <strong>==</strong> 和 <strong>!=</strong>。当断言失败时，这些宏会使用调试格式打印出其参数，这意味着被比较的值必需实现了 <strong>PartialEq</strong> 和 <strong>Debug trait</strong>。所有的基本类型和大部分标准库类型都实现了这些 trait。对于自定义的结构体和枚举，需要实现 <strong>PartialEq</strong> 才能断言他们的值是否相等。需要实现 <strong>Debug</strong> 才能在断言失败时打印他们的值。因为这两个 <strong>trait</strong> 都是派生 <strong>trait</strong>，如第五章示例 5-12 所提到的，通常可以直接在结构体或枚举上添加 <strong>#[derive(PartialEq, Debug)]</strong> 注解。附录 C “<a href="https://kaisery.github.io/trpl-zh-cn/appendix-03-derivable-traits.html">可派生 trait</a>” 中有更多关于这些和其他派生 <strong>trait</strong> 的详细信息。</p>
</ins>
<h3 id="_4">自定义失败信息</h3>
<mark class="critic block">
<p>你也可以向 <strong>assert!</strong>、<strong>assert_eq!</strong> 和 <strong>assert_ne!</strong> 宏传递一个可选的失败信息参数，可以在测试失败时将自定义失败信息一同打印出来。
任何在 <strong>assert!</strong> 的一个必需参数和 <strong>assert_eq!</strong> 和 <strong>assert_ne!</strong> 的两个必需参数之后指定的参数都会传递给 <strong>format!</strong> 宏（在第八章的 “<a href="https://kaisery.github.io/trpl-zh-cn/ch08-02-strings.html#%E4%BD%BF%E7%94%A8--%E8%BF%90%E7%AE%97%E7%AC%A6%E6%88%96-format-%E5%AE%8F%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2">使用 + 运算符或 format! 宏拼接字符串</a>” 部分讨论过），所以可以传递一个包含 <strong>{}</strong> 占位符的格式字符串和需要放入占位符的值。
自定义信息有助于记录断言的意义；当测试失败时就能更好的理解代码出了什么问题。</p>
</mark>
<p>例如，比如说有一个根据人名进行问候的函数，而我们希望测试将传递给函数的人名显示在输出中：</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">greeting</span><span class="p">(</span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">format!</span><span class="p">(</span><span class="s">&quot;Hello {}!&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">greeting_contains_name</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">greeting</span><span class="p">(</span><span class="s">&quot;Carol&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s">&quot;Carol&quot;</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>这个程序的需求还没有被确定，因此问候文本开头的 <strong>Hello</strong> 文本很可能会改变。然而我们并不想在需求改变时不得不更新测试，所以相比检查 <strong>greeting</strong> 函数返回的确切值，我们将仅仅断言输出的文本中包含输入参数。</p>
<p>让我们通过将 <strong>greeting</strong> 改为不包含 <strong>name</strong> 来在代码中引入一个 <strong>bug</strong> 来测试失败时是怎样的：</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">greeting</span><span class="p">(</span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&quot;Hello!&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>运行测试会产生：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling greeter v0.1.0 <span class="o">(</span>file:///projects/greeter<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.91s
     Running unittests <span class="o">(</span>target/debug/deps/greeter-170b942eb5bf5e3a<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread <span class="s1">&#39;main&#39;</span> panicked at <span class="s1">&#39;assertion failed: result.contains(\&quot;Carol\&quot;)&#39;</span>, src/lib.rs:12:9
note: run with <span class="sb">`</span><span class="nv">RUST_BACKTRACE</span><span class="o">=</span><span class="m">1</span><span class="sb">`</span> environment variable to display a backtrace


failures:
    tests::greeting_contains_name

<span class="nb">test</span> result: FAILED. <span class="m">0</span> passed<span class="p">;</span> <span class="m">1</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

error: <span class="nb">test</span> failed, to rerun pass <span class="s1">&#39;--lib&#39;</span>
</code></pre></div>
<p>结果仅仅告诉了我们断言失败了和失败的行号。一个更有用的失败信息应该打印出 greeting 函数的值。让我们为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 greeting 函数的值：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">greeting_contains_name</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">greeting</span><span class="p">(</span><span class="s">&quot;Carol&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">result</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s">&quot;Carol&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;Greeting did not contain name, value was `{}`&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">result</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>现在如果再次运行测试，将会看到更有价值的信息：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling greeter v0.1.0 <span class="o">(</span>file:///projects/greeter<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.93s
     Running unittests <span class="o">(</span>target/debug/deps/greeter-170b942eb5bf5e3a<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread <span class="s1">&#39;main&#39;</span> panicked at <span class="s1">&#39;Greeting did not contain name, value was `Hello!`&#39;</span>, src/lib.rs:12:9
note: run with <span class="sb">`</span><span class="nv">RUST_BACKTRACE</span><span class="o">=</span><span class="m">1</span><span class="sb">`</span> environment variable to display a backtrace


failures:
    tests::greeting_contains_name

<span class="nb">test</span> result: FAILED. <span class="m">0</span> passed<span class="p">;</span> <span class="m">1</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

error: <span class="nb">test</span> failed, to rerun pass <span class="s1">&#39;--lib&#39;</span>
</code></pre></div>
<p>可以在测试输出中看到所取得的确切的值，这会帮助我们理解真正发生了什么，而不是期望发生什么。</p>
<h3 id="panic">panic检测</h3>
<p>除了检查代码是否返回期望的正确的值之外，检查代码是否按照期望处理错误也是很重要的。
例如，考虑第九章创建的 <strong>Guess</strong> 类型。其他使用 <strong>Guess</strong> 的代码都是基于 <strong>Guess</strong> 实例仅有的值范围在 1 到 100 的前提。
可以编写一个测试来确保创建一个超出范围的值的 <strong>Guess</strong> 实例会 <strong>panic</strong>。</p>
<p>可以通过对函数增加另一个属性 <strong>should_panic</strong> 来实现这些。这个属性在函数中的代码 <strong>panic</strong> 时会通过，而在其中的代码没有 <strong>panic</strong> 时失败。</p>
<p>下面示例展示了一个检查 <strong>Guess::new</strong> 是否按照我们的期望出错的测试：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 测试会造成 panic! 的条件</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Guess</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Guess</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Guess</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;Guess value must be between 1 and 100, got {}.&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">Guess</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[should_panic]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">greater_than_100</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Guess</span>::<span class="n">new</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><strong>#[should_panic]</strong> 属性位于 <strong>#[test]</strong> 之后，对应的测试函数之前。让我们看看测试通过时它是什么样子：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling guessing_game v0.1.0 <span class="o">(</span>file:///projects/guessing_game<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.58s
     Running unittests <span class="o">(</span>target/debug/deps/guessing_game-57d70c3acb738f4d<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> tests::greater_than_100 - should panic ... ok

<span class="nb">test</span> result: ok. <span class="m">1</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

   Doc-tests guessing_game

running <span class="m">0</span> tests

<span class="nb">test</span> result: ok. <span class="m">0</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s
</code></pre></div>
<p>看起来不错！现在在代码中引入 <strong>bug</strong>，移除 <strong>new</strong> 函数在值大于 <strong>100</strong> 时会 <strong>panic</strong> 的条件：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// --snip--</span>
<span class="k">impl</span><span class="w"> </span><span class="n">Guess</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Guess</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;Guess value must be between 1 and 100, got {}.&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">Guess</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>如果运行示例的测试，它会失败：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling guessing_game v0.1.0 <span class="o">(</span>file:///projects/guessing_game<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.62s
     Running unittests <span class="o">(</span>target/debug/deps/guessing_game-57d70c3acb738f4d<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: <span class="nb">test</span> did not panic as expected

failures:
    tests::greater_than_100

<span class="nb">test</span> result: FAILED. <span class="m">0</span> passed<span class="p">;</span> <span class="m">1</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

error: <span class="nb">test</span> failed, to rerun pass <span class="s1">&#39;--lib&#39;</span>
</code></pre></div>
<p>这回并没有得到非常有用的信息，不过一旦我们观察测试函数，会发现它标注了 <strong>#[should_panic]</strong>。这个错误意味着代码中测试函数 <strong>Guess::new(200)</strong> 并没有产生 <strong>panic</strong>。</p>
<p>然而 <strong>should_panic</strong> 测试结果可能会非常含糊不清，因为它只是告诉我们代码并没有产生 <strong>panic</strong>。<strong>should_panic</strong> 甚至在一些不是我们期望的原因而导致 <strong>panic</strong> 时也会通过。
<ins class="critic">为了使 <strong>should_panic</strong> 测试结果更精确，我们可以给 <strong>should_panic</strong> 属性增加一个可选的 <strong>expected</strong> 参数。</ins>
测试工具会确保错误信息中包含其提供的文本。例如，考虑示例中修改过的 <strong>Guess</strong>，这里 <strong>new</strong> 函数根据其值是过大还或者过小而提供不同的 <strong>panic</strong> 信息：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// --snip--</span>
<span class="k">impl</span><span class="w"> </span><span class="n">Guess</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Guess</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">panic!</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="s">&quot;Guess value must be greater than or equal to 1, got {}.&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">value</span><span class="w"></span>
<span class="w">            </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">panic!</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="s">&quot;Guess value must be less than or equal to 100, got {}.&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">value</span><span class="w"></span>
<span class="w">            </span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">Guess</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[should_panic(expected = </span><span class="s">&quot;Guess value must be less than or equal to 100&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">greater_than_100</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Guess</span>::<span class="n">new</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>这个测试会通过，因为 <strong>should_panic</strong> 属性中 <strong>expected</strong> 参数提供的值是 <strong>Guess::new</strong> 函数 <strong>panic</strong> 信息的子串。
我们可以指定期望的整个 <strong>panic</strong> 信息，在这个例子中是 <strong>Guess value must be less than or equal to 100, got 200.</strong>。
<strong>expected</strong> 信息的选择取决于 <strong>panic</strong> 信息有多独特或动态，和你希望测试有多准确。
在这个例子中，错误信息的子字符串足以确保函数在 <strong>else if value &gt; 100</strong> 的情况下运行。</p>
<p>为了观察带有 <strong>expected</strong> 信息的 <strong>should_panic</strong> 测试失败时会发生什么，让我们再次引入一个 <strong>bug</strong>，将 <code>if value &lt; 1</code> 和 <code>else if value &gt; 100</code> 的代码块对换：</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">panic!</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;Guess value must be less than or equal to 100, got {}.&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">panic!</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="s">&quot;Guess value must be greater than or equal to 1, got {}.&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>这一次运行 <strong>should_panic</strong> 测试，它会失败：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling guessing_game v0.1.0 <span class="o">(</span>file:///projects/guessing_game<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.66s
     Running unittests <span class="o">(</span>target/debug/deps/guessing_game-57d70c3acb738f4d<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread <span class="s1">&#39;main&#39;</span> panicked at <span class="s1">&#39;Guess value must be greater than or equal to 1, got 200.&#39;</span>, src/lib.rs:13:13
note: run with <span class="sb">`</span><span class="nv">RUST_BACKTRACE</span><span class="o">=</span><span class="m">1</span><span class="sb">`</span> environment variable to display a backtrace
note: panic did not contain expected string
      panic message: <span class="sb">`</span><span class="s2">&quot;Guess value must be greater than or equal to 1, got 200.&quot;</span><span class="sb">`</span>,
 expected substring: <span class="sb">`</span><span class="s2">&quot;Guess value must be less than or equal to 100&quot;</span><span class="sb">`</span>

failures:
    tests::greater_than_100

<span class="nb">test</span> result: FAILED. <span class="m">0</span> passed<span class="p">;</span> <span class="m">1</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

error: <span class="nb">test</span> failed, to rerun pass <span class="s1">&#39;--lib&#39;</span>
</code></pre></div>
<p>失败信息表明测试确实如期望 <strong>panic</strong> 了，不过 <strong>panic</strong> 信息中并没有包含 <strong>expected</strong> 信息 <strong>'Guess value must be less than or equal to 100'</strong>。
而我们得到的 <strong>panic</strong> 信息是 <strong>'Guess value must be greater than or equal to 1, got 200.'</strong>。这样就可以开始寻找 <strong>bug</strong> 在哪了！</p>
<h3 id="resultt-e">Result&lt;T, E>测试</h3>
<p>目前为止，我们编写的测试在失败时就会 <strong>panic</strong>。也可以使用 <strong>Result\&lt;T, E></strong> 编写测试！这里是第一个例子采用了 <strong>Result</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">it_works</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&quot;two plus two does not equal four&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>现在 <code>it_works</code> 函数的返回值类型为 <strong>Result&lt;(), String&gt;</strong>。在函数体中，不同于调用 <strong>assert_eq!</strong> 宏，而是在测试通过时返回 <strong>Ok(())</strong>，在测试失败时返回带有 <strong>String</strong> 的 <strong>Err</strong>。</p>
<p>这样编写测试来返回 <strong>Result\&lt;T, E></strong> 就可以在函数体中使用问号运算符，如此可以方便的编写任何运算符会返回 <strong>Err</strong> 成员的测试。</p>
<ins class="critic block">
<p>不能对这些使用 <strong>Result<T, E></strong> 的测试使用 <strong>#[should_panic]</strong> 注解。为了断言一个操作返回 <strong>Err</strong> 成员，不要使用对 <strong>Result\&lt;T, E></strong> 值使用问号表达式（?）。而是使用 <strong>assert!(value.is_err())</strong>。</p>
</ins>
<p>现在你知道了几种编写测试的方法，让我们看看运行测试时会发生什么，和可以用于 <code>cargo test</code> 的不同选项。</p>
<h2 id="_5">控制如何运行</h2>
<p><ins class="critic">就像 <code>cargo run</code> 会编译代码并运行生成的二进制文件一样，<code>cargo test</code> 在测试模式下编译代码并运行生成的测试二进制文件。可以指定命令行参数来改变 <code>cargo test</code> 的默认行为。</ins>
例如，<code>cargo test</code> 生成的二进制文件的默认行为是<strong>并行</strong>的运行所有测试，并截获测试运行过程中产生的输出，阻止他们被显示出来，使得阅读测试结果相关的内容变得更容易。</p>
<p>可以将一部分命令行参数传递给 <code>cargo test</code>，而将另外一部分传递给生成的测试二进制文件。为了分隔这两种参数，需要先列出传递给 <code>cargo test</code> 的参数，接着是分隔符 <code>--</code>，再之后是传递给测试二进制文件的参数。运行 <code>cargo test --help</code> 会提示 <code>cargo test</code> 的有关参数，而运行 <code>cargo test -- --help</code> 可以提示在分隔符 <code>--</code> 之后使用的有关参数。</p>
<h3 id="_6">并行或连续测试</h3>
<mark class="critic block">
<p>当运行多个测试时， Rust 默认使用线程来并行运行。这意味着测试会更快地运行完毕，所以你可以更快的得到代码能否工作的反馈。因为测试是在同时运行的，你应该确保测试<strong>不能相互依赖，或依赖任何共享的状态，包括依赖共享的环境</strong>，比如当前工作目录或者环境变量。</p>
</mark>
<p>举个例子，每一个测试都运行一些代码，假设这些代码都在硬盘上创建一个 test-output.txt 文件并写入一些数据。接着每一个测试都读取文件中的数据并断言这个文件包含特定的值，而这个值在每个测试中都是不同的。因为所有测试都是同时运行的，一个测试可能会在另一个测试读写文件过程中修改了文件。那么第二个测试就会失败，并不是因为代码不正确，而是因为测试并行运行时相互干扰。一个解决方案是使每一个测试读写不同的文件；另一个解决方案是一次运行一个测试。</p>
<p>如果你不希望测试并行运行，或者想要更加精确的控制线程的数量，可以传递 <code>--test-threads</code> 参数和希望使用线程的数量给测试二进制文件。例如：</p>
<div class="highlight"><pre><span></span><code>cargo <span class="nb">test</span> -- --test-threads<span class="o">=</span><span class="m">1</span>
</code></pre></div>
<p>这里将测试线程设置为 1，告诉程序不要使用任何并行机制。这也会比并行运行花费更多时间，不过在有共享的状态时，测试就不会潜在的相互干扰了。</p>
<h3 id="_7">显示函数输出</h3>
<p><strong>默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容。</strong>
比如在测试中调用了 <strong>println!</strong> 而测试通过了，我们将不会在终端看到 <strong>println!</strong> 的输出：只会看到说明测试通过的提示行。
<strong>如果测试失败了，则会看到所有标准输出和其他错误信息。</strong></p>
<p>例如，示例有一个无意义的函数，它打印出其参数的值并接着返回 <strong>10</strong>。接着还有一个会通过的测试和一个会失败的测试：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 一个调用了 println! 的函数的测试</span>

<span class="k">fn</span> <span class="nf">prints_and_returns_10</span><span class="p">(</span><span class="n">a</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;I got the value {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="mi">10</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">this_test_will_pass</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prints_and_returns_10</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">this_test_will_fail</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prints_and_returns_10</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>运行 <code>cargo test</code> 将会看到这些测试的输出：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling silly-function v0.1.0 <span class="o">(</span>file:///projects/silly-function<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.58s
     Running unittests <span class="o">(</span>target/debug/deps/silly_function-160869f38cff9166<span class="o">)</span>

running <span class="m">2</span> tests
<span class="nb">test</span> tests::this_test_will_fail ... FAILED
<span class="nb">test</span> tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value <span class="m">8</span>
thread <span class="s1">&#39;main&#39;</span> panicked at <span class="s1">&#39;assertion failed: `(left == right)`</span>
<span class="s1">  left: `5`,</span>
<span class="s1"> right: `10`&#39;</span>, src/lib.rs:19:9
note: run with <span class="sb">`</span><span class="nv">RUST_BACKTRACE</span><span class="o">=</span><span class="m">1</span><span class="sb">`</span> environment variable to display a backtrace


failures:
    tests::this_test_will_fail

<span class="nb">test</span> result: FAILED. <span class="m">1</span> passed<span class="p">;</span> <span class="m">1</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

error: <span class="nb">test</span> failed, to rerun pass <span class="s1">&#39;--lib&#39;</span>
</code></pre></div>
<p>注意输出中不会出现测试通过时打印的内容，即 <strong>I got the value 4</strong>。因为当测试通过时，这些输出会被截获。失败测试的输出 <strong>I got the value 8</strong> ，则出现在输出的测试摘要部分，同时也显示了测试失败的原因。</p>
<p>如果你希望也能看到通过的测试中打印的值，也可以在结尾加上 <code>--show-output</code> 告诉 Rust 显示成功测试的输出。</p>
<div class="highlight"><pre><span></span><code>cargo <span class="nb">test</span> -- --show-output
</code></pre></div>
<p>使用 <code>--show-output</code> 参数再次运行示例中的测试会显示如下输出：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span> -- --show-output
   Compiling silly-function v0.1.0 <span class="o">(</span>file:///projects/silly-function<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.60s
     Running unittests <span class="o">(</span>target/debug/deps/silly_function-160869f38cff9166<span class="o">)</span>

running <span class="m">2</span> tests
<span class="nb">test</span> tests::this_test_will_fail ... FAILED
<span class="nb">test</span> tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value <span class="m">4</span>


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value <span class="m">8</span>
thread <span class="s1">&#39;main&#39;</span> panicked at <span class="s1">&#39;assertion failed: `(left == right)`</span>
<span class="s1">  left: `5`,</span>
<span class="s1"> right: `10`&#39;</span>, src/lib.rs:19:9
note: run with <span class="sb">`</span><span class="nv">RUST_BACKTRACE</span><span class="o">=</span><span class="m">1</span><span class="sb">`</span> environment variable to display a backtrace


failures:
    tests::this_test_will_fail

<span class="nb">test</span> result: FAILED. <span class="m">1</span> passed<span class="p">;</span> <span class="m">1</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

error: <span class="nb">test</span> failed, to rerun pass <span class="s1">&#39;--lib&#39;</span>
</code></pre></div>
<h3 id="_8">指定名称运行部分测试</h3>
<p>有时运行整个测试集会耗费很长时间。如果你负责特定位置的代码，你可能会希望只运行与这些代码相关的测试。你可以向 <strong>cargo test</strong> 传递所希望运行的测试名称的参数来选择运行哪些测试。</p>
<p>为了展示如何运行部分测试，示例为 <code>add_two</code> 函数创建了三个测试，我们可以选择具体运行哪一个：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 不同名称的三个测试</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add_two</span><span class="p">(</span><span class="n">a</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">add_two_and_two</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">add_two</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">add_three_and_two</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">add_two</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">one_hundred</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">102</span><span class="p">,</span><span class="w"> </span><span class="n">add_two</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>如果没有传递任何参数就运行测试，如你所见，所有测试都会并行运行：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling adder v0.1.0 <span class="o">(</span>file:///projects/adder<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.62s
     Running unittests <span class="o">(</span>target/debug/deps/adder-92948b65e88960b4<span class="o">)</span>

running <span class="m">3</span> tests
<span class="nb">test</span> tests::add_three_and_two ... ok
<span class="nb">test</span> tests::add_two_and_two ... ok
<span class="nb">test</span> tests::one_hundred ... ok

<span class="nb">test</span> result: ok. <span class="m">3</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

   Doc-tests adder

running <span class="m">0</span> tests

<span class="nb">test</span> result: ok. <span class="m">0</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s
</code></pre></div>
<h4 id="_9">单个测试</h4>
<p>可以向 <strong>cargo test</strong> 传递任意测试的名称来只运行这个测试：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span> one_hundred
   Compiling adder v0.1.0 <span class="o">(</span>file:///projects/adder<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.69s
     Running unittests <span class="o">(</span>target/debug/deps/adder-92948b65e88960b4<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> tests::one_hundred ... ok

<span class="nb">test</span> result: ok. <span class="m">1</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">2</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s
</code></pre></div>
<p>只有名称为 <strong>one_hundred</strong> 的测试被运行了；因为其余两个测试并不匹配这个名称。测试输出在摘要行的结尾显示了 <strong>2 filtered out</strong> 表明还存在比本次所运行的测试更多的测试被过滤掉了。</p>
<p>不能像这样指定多个测试名称；只有传递给 <strong>cargo test</strong> 的第一个值才会被使用。不过有运行多个测试的方法。</p>
<h4 id="_10">过滤运行多个测试</h4>
<p>我们可以指定部分测试的名称，任何名称匹配这个名称的测试会被运行。例如，因为头两个测试的名称包含 <strong>add</strong>，可以通过 <strong>cargo test add</strong> 来运行这两个测试：</p>
<div class="highlight"><pre><span></span><code><span class="cp">$</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="n">add</span><span class="w"></span>
<span class="w">   </span><span class="n">Compiling</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="n">v0</span><span class="p">.</span><span class="mf">1.0</span><span class="w"> </span><span class="p">(</span><span class="n">file</span>:<span class="sd">///projects/adder)</span>
<span class="w">    </span><span class="n">Finished</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="p">[</span><span class="n">unoptimized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">debuginfo</span><span class="p">]</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.61</span><span class="n">s</span><span class="w"></span>
<span class="w">     </span><span class="n">Running</span><span class="w"> </span><span class="n">unittests</span><span class="w"> </span><span class="p">(</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">deps</span><span class="o">/</span><span class="n">adder</span><span class="o">-</span><span class="mi">92948</span><span class="n">b65e88960b4</span><span class="p">)</span><span class="w"></span>

<span class="n">running</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">tests</span><span class="w"></span>
<span class="n">test</span><span class="w"> </span><span class="n">tests</span>::<span class="n">add_three_and_two</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="n">ok</span><span class="w"></span>
<span class="n">test</span><span class="w"> </span><span class="n">tests</span>::<span class="n">add_two_and_two</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="n">ok</span><span class="w"></span>

<span class="n">test</span><span class="w"> </span><span class="n">result</span>: <span class="nc">ok</span><span class="p">.</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">passed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">failed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">ignored</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">measured</span><span class="p">;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">filtered</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.00</span><span class="n">s</span><span class="w"></span>
</code></pre></div>
<p>这运行了所有名字中带有 <strong>add</strong> 的测试，也过滤掉了名为 <strong>one_hundred</strong> 的测试。同时注意测试所在的模块也是测试名称的一部分，所以可以通过模块名来运行一个模块中的所有测试。</p>
<h3 id="_11">忽略某些测试</h3>
<p><ins class="critic">
有时一些特定的测试执行起来是非常耗费时间的，所以在大多数运行 <strong>cargo test</strong> 的时候希望能排除他们。
虽然可以通过参数列举出所有希望运行的测试来做到，也可以使用 <strong>ignore</strong> 属性来标记耗时的测试并排除他们，
</ins></p>
<p>如下所示：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[test]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">it_works</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[test]</span><span class="w"></span>
<span class="cp">#[ignore]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">expensive_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 需要运行一个小时的代码</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>对于想要排除的测试，我们在 <strong>#[test]</strong> 之后增加了 <strong>#[ignore]</strong> 行。现在如果运行测试，就会发现 <strong>it_works</strong> 运行了，而 <strong>expensive_test</strong> 没有运行：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling adder v0.1.0 <span class="o">(</span>file:///projects/adder<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.60s
     Running unittests <span class="o">(</span>target/debug/deps/adder-92948b65e88960b4<span class="o">)</span>

running <span class="m">2</span> tests
<span class="nb">test</span> expensive_test ... ignored
<span class="nb">test</span> it_works ... ok

<span class="nb">test</span> result: ok. <span class="m">1</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">1</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

   Doc-tests adder

running <span class="m">0</span> tests

<span class="nb">test</span> result: ok. <span class="m">0</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s
</code></pre></div>
<p><strong>expensive_test</strong> 被列为 <code>ignored</code>，如果我们只希望运行被忽略的测试，可以使用 <code>cargo test -- --ignored</code>：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span> -- --ignored
   Compiling adder v0.1.0 <span class="o">(</span>file:///projects/adder<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.61s
     Running unittests <span class="o">(</span>target/debug/deps/adder-92948b65e88960b4<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> expensive_test ... ok

<span class="nb">test</span> result: ok. <span class="m">1</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">1</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

   Doc-tests adder

running <span class="m">0</span> tests

<span class="nb">test</span> result: ok. <span class="m">0</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s
</code></pre></div>
<p>通过控制运行哪些测试，你可以确保能够快速地运行 <code>cargo test</code> 。<ins class="critic">当你需要运行 <strong>ignored</strong> 的测试时，可以执行 <code>cargo test -- --ignored</code>。
如果你希望不管是否忽略都要运行全部测试，可以运行 <code>cargo test -- --include-ignored</code>。</ins></p>
<h2 id="_12">测试的组织结构</h2>
<mark class="critic block">
<p>本章一开始就提到，测试是一个复杂的概念，而且不同的开发者也采用不同的技术和组织。
Rust 社区倾向于根据测试的两个主要分类来考虑问题：<strong>单元测试</strong>（unit tests）与 <strong>集成测试</strong>（integration tests）。</p>
<ul>
<li>单元测试倾向于更小而更集中，在隔离的环境中一次测试一个模块，或者是测试私有接口。</li>
<li>而集成测试对于你的库来说则完全是外部的。它们与其他外部代码一样，通过相同的方式使用你的代码，只测试公有接口而且每个测试都有可能会测试多个模块。</li>
</ul>
<p>为了保证你的库能够按照你的预期运行，从独立和整体的角度编写这两类测试都是非常重要的。</p>
</mark>
<h3 id="_13">单元测试</h3>
<mark class="critic block">
<p>单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确的某个单元的代码功能是否符合预期。
单元测试与他们要测试的代码共同存放在位于 <strong>src</strong> 目录下相同的文件中。
规范是在每个文件中创建包含测试函数的 <strong>tests</strong> 模块，并使用 <strong>cfg(test)</strong> 标注模块。</p>
</mark>
<h4 id="cfgtest">测试模块和 #[cfg(test)]</h4>
<mark class="critic block">
<p>测试模块的 <strong>#[cfg(test)]</strong> 注解告诉 Rust 只在执行 <code>cargo test</code> 时才编译和运行测试代码，而在运行 <code>cargo build</code> 时不这么做。
这在只希望构建库的时候可以节省编译时间，并且因为它们并没有包含测试，所以能减少编译产生的文件的大小。
与之对应的集成测试因为位于另一个文件夹，所以它们并不需要 <strong>#[cfg(test)]</strong> 注解。
然而单元测试位于与源码相同的文件中，所以你需要使用 <strong>#[cfg(test)]</strong> 来指定他们不应该被包含进编译结果中。</p>
</mark>
<p>回忆本章第一部分新建的 <strong>adder</strong> 项目，<strong>Cargo</strong> 为我们生成了如下代码：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">it_works</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>上述代码就是自动生成的测试模块。<strong>cfg</strong> 属性代表 <strong>configuration</strong> ，它告诉 Rust 其之后的项只应该被包含进特定配置选项中。
在这个例子中，配置选项是 <strong>test</strong>，即 Rust 所提供的用于编译和运行测试的配置选项。
通过使用 <strong>cfg</strong> 属性，<strong>Cargo</strong> 只会在我们主动使用 <strong>cargo test</strong> 运行测试时才编译测试代码。这包括测试模块中可能存在的帮助函数， 以及标注为 <strong>#[test]</strong> 的函数。</p>
<h4 id="_14">测试私有函数</h4>
<p><strong>测试社区中一直存在关于是否应该对私有函数直接进行测试的论战，而在其他语言中想要测试私有函数是一件困难的，甚至是不可能的事。
不过无论你坚持哪种测试意识形态，Rust 的私有性规则确实允许你测试私有函数。</strong></p>
<p>考虑示例中带有私有函数 <strong>internal_adder</strong> 的代码：</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add_two</span><span class="p">(</span><span class="n">a</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">internal_adder</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">internal_adder</span><span class="p">(</span><span class="n">a</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[cfg(test)]</span><span class="w"></span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">internal</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">internal_adder</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>注意 <strong>internal_adder</strong> 函数并没有标记为 <strong>pub</strong>。测试也不过是 Rust 代码，同时 <strong>tests</strong> 也仅仅是另一个模块。
正如 “路径用于引用模块树中的项” 部分所说，子模块的项可以使用其上级模块的项。
在测试中，我们通过 <strong>use super::</strong><em> 将 </em><em>test</em><em> 模块的父模块的所有项引入了作用域，接着测试调用了 </em><em>internal_adder</em>*。
如果你并不认为应该测试私有函数，Rust 也不会强迫你这么做。</p>
<h3 id="_15">集成测试</h3>
<p>在 Rust 中，集成测试对于你需要测试的库来说完全是外部的。同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 <strong>API</strong> 。
<ins class="critic"><strong>集成测试的目的是测试库的多个部分能否一起正常工作。一些单独能正确运行的代码单元集成在一起也可能会出现问题，所以集成测试的覆盖率也是很重要的。</strong></ins>
为了创建集成测试，你需要先创建一个 <strong>tests</strong> 目录。</p>
<h4 id="tests">tests 目录</h4>
<p>为了编写集成测试，需要在项目根目录创建一个 <strong>tests</strong> 目录，与 <strong>src</strong> 同级。<strong>Cargo</strong> 知道如何去寻找这个目录中的集成测试文件。接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 <strong>crate</strong> 来编译。</p>
<p>让我们来创建一个集成测试。保留上个示例中 <strong>src/lib.rs</strong> 的代码。创建一个 <strong>tests</strong> 目录，新建一个文件 <strong>tests/integration_test.rs</strong>，并输入下面示例中的代码。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 文件名: tests/integration_test.rs</span>

<span class="k">use</span><span class="w"> </span><span class="n">adder</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[test]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">it_adds_two</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">adder</span>::<span class="n">add_two</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>与单元测试不同，我们需要在文件顶部添加 <strong>use adder</strong>。这是因为每一个 <strong>tests</strong> 目录中的测试文件都是完全独立的 <strong>crate</strong>，所以需要在每一个文件中导入库。</p>
<p>并不需要将 <strong>tests/integration_test.rs</strong> 中的任何代码标注为 <strong>#[cfg(test)]</strong>。 <strong>tests</strong> 文件夹在 <strong>Cargo</strong> 中是一个特殊的文件夹， <strong>Cargo</strong> 只会在运行 <strong>cargo test</strong> 时编译这个目录中的文件。现在就运行 <strong>cargo test</strong> 试试：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling adder v0.1.0 <span class="o">(</span>file:///projects/adder<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">1</span>.31s
     Running unittests <span class="o">(</span>target/debug/deps/adder-1082c4b063a8fbe6<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> tests::internal ... ok

<span class="nb">test</span> result: ok. <span class="m">1</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

     Running tests/integration_test.rs <span class="o">(</span>target/debug/deps/integration_test-1082c4b063a8fbe6<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> it_adds_two ... ok

<span class="nb">test</span> result: ok. <span class="m">1</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

   Doc-tests adder

running <span class="m">0</span> tests

<span class="nb">test</span> result: ok. <span class="m">0</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s
</code></pre></div>
<p>现在有了三个部分的输出：<strong>单元测试</strong>、<strong>集成测试</strong>和<strong>文档测试</strong>。第一部分单元测试与我们之前见过的一样：每个单元测试一行（示例中有一个叫做 <strong>internal</strong> 的测试），接着是一个单元测试的摘要行。</p>
<p>集成测试部分以行 <strong>Running target/debug/deps/integration-test-ce99bcc2479f4607</strong>（在输出最后的哈希值可能不同）开头。接下来每一行是一个集成测试中的测试函数，以及一个位于 <strong>Doc-tests adder</strong> 部分之前的集成测试的摘要行。</p>
<p>我们已经知道，单元测试函数越多，单元测试部分的结果行就会越多。同样的，在集成文件中增加的测试函数越多，也会在对应的测试结果部分增加越多的结果行。每一个集成测试文件有对应的测试结果部分，所以如果在 <strong>tests</strong> 目录中增加更多文件，测试结果中就会有更多集成测试结果部分。</p>
<p>我们仍然可以通过指定测试函数的名称作为 <strong>cargo test</strong> 的参数来运行特定集成测试。也可以使用 <strong>cargo test</strong> 的 <code>--test</code> 后跟文件的名称来运行某个特定集成测试文件中的所有测试：</p>
<div class="highlight"><pre><span></span><code><span class="cp">$</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">--</span><span class="n">test</span><span class="w"> </span><span class="n">integration_test</span><span class="w"></span>
<span class="w">   </span><span class="n">Compiling</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="n">v0</span><span class="p">.</span><span class="mf">1.0</span><span class="w"> </span><span class="p">(</span><span class="n">file</span>:<span class="sd">///projects/adder)</span>
<span class="w">    </span><span class="n">Finished</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="p">[</span><span class="n">unoptimized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">debuginfo</span><span class="p">]</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.64</span><span class="n">s</span><span class="w"></span>
<span class="w">     </span><span class="n">Running</span><span class="w"> </span><span class="n">tests</span><span class="o">/</span><span class="n">integration_test</span><span class="p">.</span><span class="n">rs</span><span class="w"> </span><span class="p">(</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">deps</span><span class="o">/</span><span class="n">integration_test</span><span class="o">-</span><span class="mf">82e7799</span><span class="n">c1bc62298</span><span class="p">)</span><span class="w"></span>

<span class="n">running</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">test</span><span class="w"></span>
<span class="n">test</span><span class="w"> </span><span class="n">it_adds_two</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="n">ok</span><span class="w"></span>

<span class="n">test</span><span class="w"> </span><span class="n">result</span>: <span class="nc">ok</span><span class="p">.</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">passed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">failed</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">ignored</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">measured</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">filtered</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="n">finished</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.00</span><span class="n">s</span><span class="w"></span>
</code></pre></div>
<p>这个命令只运行了 <strong>tests</strong> 目录中我们指定的文件 <strong>integration_test.rs</strong> 中的测试。</p>
<h4 id="_16">集成测试中的子模块</h4>
<p>随着集成测试的增加，你可能希望在 <strong>tests</strong> 目录增加更多文件以便更好的组织他们，例如根据测试的功能来将测试分组。正如我们之前提到的，每一个 <strong>tests</strong> 目录中的文件都被编译为单独的 crate。</p>
<p>将每个集成测试文件当作其自己的 <strong>crate</strong> 来对待，这更有助于创建单独的作用域，这种单独的作用域能提供更类似与最终使用者使用 <strong>crate</strong> 的环境。然而，正如你在第七章中学习的如何将代码分为模块和文件的知识，<strong>tests</strong> 目录中的文件不能像 <strong>src</strong> 中的文件那样共享相同的行为。</p>
<p>当你有一些在多个集成测试文件都会用到的帮助函数，而你尝试按照第七章 “将模块移动到其他文件” 部分的步骤将他们提取到一个通用的模块中时， tests 目录中不同文件的行为就会显得很明显。例如，如果我们可以创建 一个<strong>tests/common.rs</strong> 文件并创建一个名叫 <strong>setup</strong> 的函数，我们希望这个函数能被多个测试文件的测试函数调用：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 文件名: tests/common.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">setup</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// setup code specific to your library&#39;s tests would go here</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>如果再次运行测试，将会在测试结果中看到一个新的对应 <strong>common.rs</strong> 文件的测试结果部分，即便这个文件并没有包含任何测试函数，也没有任何地方调用了 <strong>setup</strong> 函数：</p>
<div class="highlight"><pre><span></span><code>$ cargo <span class="nb">test</span>
   Compiling adder v0.1.0 <span class="o">(</span>file:///projects/adder<span class="o">)</span>
    Finished <span class="nb">test</span> <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> <span class="k">in</span> <span class="m">0</span>.89s
     Running unittests <span class="o">(</span>target/debug/deps/adder-92948b65e88960b4<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> tests::internal ... ok

<span class="nb">test</span> result: ok. <span class="m">1</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

     Running tests/common.rs <span class="o">(</span>target/debug/deps/common-92948b65e88960b4<span class="o">)</span>

running <span class="m">0</span> tests

<span class="nb">test</span> result: ok. <span class="m">0</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

     Running tests/integration_test.rs <span class="o">(</span>target/debug/deps/integration_test-92948b65e88960b4<span class="o">)</span>

running <span class="m">1</span> <span class="nb">test</span>
<span class="nb">test</span> it_adds_two ... ok

<span class="nb">test</span> result: ok. <span class="m">1</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s

   Doc-tests adder

running <span class="m">0</span> tests

<span class="nb">test</span> result: ok. <span class="m">0</span> passed<span class="p">;</span> <span class="m">0</span> failed<span class="p">;</span> <span class="m">0</span> ignored<span class="p">;</span> <span class="m">0</span> measured<span class="p">;</span> <span class="m">0</span> filtered out<span class="p">;</span> finished <span class="k">in</span> <span class="m">0</span>.00s
</code></pre></div>
<p>我们并不想要 <strong>common</strong> 出现在测试结果中显示 <strong>running 0 tests</strong> 。我们只是希望其能被其他多个集成测试文件中调用罢了。</p>
<p>为了不让 <strong>common</strong> 出现在测试输出中，我们将创建 <strong>tests/common/mod.rs</strong> ，而不是创建 <strong>tests/common.rs</strong> 。
这是一种 Rust 的命名规范，这样命名告诉 Rust 不要将 <strong>common</strong> 看作一个集成测试文件。
将 <strong>setup</strong> 函数代码移动到 <strong>tests/common/mod.rs</strong> 并删除 <strong>tests/common.rs</strong> 文件之后，测试输出中将不会出现这一部分。
<strong>tests</strong> 目录中的子目录不会被作为单独的 <strong>crate</strong> 编译或作为一个测试结果部分出现在测试输出中。</p>
<p>一旦拥有了 <strong>tests/common/mod.rs</strong>，就可以将其作为模块以便在任何集成测试文件中使用。
这里是一个 <strong>tests/integration_test.rs</strong> 中调用 <strong>setup</strong> 函数的 <strong>it_adds_two</strong> 测试的例子：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 文件名: tests/integration_test.rs</span>

<span class="k">use</span><span class="w"> </span><span class="n">adder</span><span class="p">;</span><span class="w"></span>

<span class="k">mod</span> <span class="nn">common</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[test]</span><span class="w"></span>
<span class="k">fn</span> <span class="nf">it_adds_two</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">common</span>::<span class="n">setup</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">adder</span>::<span class="n">add_two</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>注意 <strong>mod common;</strong> 声明与上面示例中展示的模块声明相同。接着在测试函数中就可以调用 <strong>common::setup()</strong> 了。</p>
<h4 id="crate">二进制 crate 的集成测试</h4>
<p>如果项目是二进制 <strong>crate</strong> 并且只包含 <strong>src/main.rs</strong> 而没有 <strong>src/lib.rs</strong>，这样就不可能在 <strong>tests</strong> 目录创建集成测试并使用 <strong>extern crate</strong> 导入 <strong>src/main.rs</strong> 中定义的函数。
只有库 <strong>crate</strong> 才会向其他 <strong>crate</strong> 暴露了可供调用和使用的函数；二进制 <strong>crate</strong> 只意在单独运行。</p>
<p>这就是许多 Rust 二进制项目使用一个简单的 <strong>src/main.rs</strong> 调用 <strong>src/lib.rs</strong> 中的逻辑的原因之一。
因为通过这种结构，<strong>集成测试</strong> 就可以 <strong>通过</strong> <strong>extern crate</strong> 测试库 <strong>crate</strong> 中的主要功能了，而如果这些重要的功能没有问题的话，<strong>src/main.rs</strong> 中的少量代码也就会正常工作且不需要测试。</p>
<h2 id="_17">总结</h2>
<p>Rust 的测试功能提供了一个确保即使你改变了函数的实现方式，也能继续以期望的方式运行的途径。
<strong>单元测试独立地验证库的不同部分，也能够测试私有函数实现细节。</strong>
<strong>集成测试则检查多个部分是否能结合起来正确地工作，并像其他外部代码那样测试库的公有 API。</strong>
即使 Rust 的类型系统和所有权规则可以帮助避免一些 bug，不过测试对于减少代码中不符合期望行为的逻辑 bug 仍然是很重要的。</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="页脚" >
      
        
        <a href="../generics/" class="md-footer__link md-footer__link--prev" aria-label="上一页: 泛型/Trait/生命周期" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                上一页
              </span>
              泛型/Trait/生命周期
            </div>
          </div>
        </a>
      
      
        
        <a href="../an-io-project/" class="md-footer__link md-footer__link--next" aria-label="下一页: 构建一个命令行程序" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                下一页
              </span>
              构建一个命令行程序
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.16e2a7d4.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../assets/javascripts/bundle.5a2dcb6a.min.js"></script>
      
    
    
  </body>
</html>