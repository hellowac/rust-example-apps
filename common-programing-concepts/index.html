
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-8.5.10">
    
    
      
        <title>常见编程概念 - 我的rust学习示例APPS</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.975780f9.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.2505c338.min.css">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="None" data-md-color-accent="None">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href=".." title="我的rust学习示例APPS" class="md-header__button md-logo" aria-label="我的rust学习示例APPS" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            我的rust学习示例APPS
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              常见编程概念
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="我的rust学习示例APPS" class="md-nav__button md-logo" aria-label="我的rust学习示例APPS" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    我的rust学习示例APPS
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        简介
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../hello-world/" class="md-nav__link">
        hello world
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../hello-cargo/" class="md-nav__link">
        Hello Cargo
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../guessing-game/" class="md-nav__link">
        猜数游戏
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          常见编程概念
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        常见编程概念
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    变量和可变性
  </a>
  
    <nav class="md-nav" aria-label="变量和可变性">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    常量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    隐藏
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    数据类型
  </a>
  
    <nav class="md-nav" aria-label="数据类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    标量类型
  </a>
  
    <nav class="md-nav" aria-label="标量类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    整型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    浮点型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    数值运算
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    布尔型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    字符类型
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    复合类型
  </a>
  
    <nav class="md-nav" aria-label="复合类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    元组类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    数组类型
  </a>
  
    <nav class="md-nav" aria-label="数组类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    访问数组元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    数组越界访问
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    函数
  </a>
  
    <nav class="md-nav" aria-label="函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    参数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    语句和表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    具有返回值的函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    注释
  </a>
  
    <nav class="md-nav" aria-label="注释">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    单行注释
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    文档注释
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    控制流
  </a>
  
    <nav class="md-nav" aria-label="控制流">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#if" class="md-nav__link">
    if表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#else-if" class="md-nav__link">
    else if 表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#letif" class="md-nav__link">
    let中的if
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    循环表达式
  </a>
  
    <nav class="md-nav" aria-label="循环表达式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#loop" class="md-nav__link">
    loop 循环
  </a>
  
    <nav class="md-nav" aria-label="loop 循环">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    从循环返回值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    循环标签
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#while" class="md-nav__link">
    while 循环
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#for" class="md-nav__link">
    for 循环
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../ownership/" class="md-nav__link">
        所有权
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../struct/" class="md-nav__link">
        结构体
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../enumerations/" class="md-nav__link">
        枚举
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../packages/" class="md-nav__link">
        包、crate、模块
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../common-collections/" class="md-nav__link">
        常见集合
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../error-handing/" class="md-nav__link">
        错误处理
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    变量和可变性
  </a>
  
    <nav class="md-nav" aria-label="变量和可变性">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    常量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    隐藏
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    数据类型
  </a>
  
    <nav class="md-nav" aria-label="数据类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    标量类型
  </a>
  
    <nav class="md-nav" aria-label="标量类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    整型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    浮点型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    数值运算
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    布尔型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    字符类型
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    复合类型
  </a>
  
    <nav class="md-nav" aria-label="复合类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    元组类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    数组类型
  </a>
  
    <nav class="md-nav" aria-label="数组类型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    访问数组元素
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    数组越界访问
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    函数
  </a>
  
    <nav class="md-nav" aria-label="函数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    参数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    语句和表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    具有返回值的函数
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    注释
  </a>
  
    <nav class="md-nav" aria-label="注释">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    单行注释
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    文档注释
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    控制流
  </a>
  
    <nav class="md-nav" aria-label="控制流">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#if" class="md-nav__link">
    if表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#else-if" class="md-nav__link">
    else if 表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#letif" class="md-nav__link">
    let中的if
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    循环表达式
  </a>
  
    <nav class="md-nav" aria-label="循环表达式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#loop" class="md-nav__link">
    loop 循环
  </a>
  
    <nav class="md-nav" aria-label="loop 循环">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    从循环返回值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    循环标签
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#while" class="md-nav__link">
    while 循环
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#for" class="md-nav__link">
    for 循环
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="_1">常见编程概念</h1>
<h2 id="_2">变量和可变性</h2>
<p>变量默认是不可改变的（immutable）。</p>
<p>当变量不可变时，一旦值被绑定一个名称上，你就不能改变这个值。</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The value of x is: {x}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w">      </span><span class="c1">// 错误, 不能对不可变变量 x 二次赋值（cannot assign twice to immutable variable `x` ）</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The value of x is: {x}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>不过可变性也是非常有用的，可以用来更方便地编写代码。尽管变量默认是不可变的，你仍然可以在变量名前添加 <code>mut</code> 来使其可变:</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">  </span><span class="c1">// 添加mut，使其可变。（进行多次赋值）</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The value of x is: {x}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The value of x is: {x}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="_3">常量</h3>
<p>类似于不可变变量，常量(constants) 是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。</p>
<ol>
<li>不允许对常量使用 mut。常量不光默认不能变，它总是不能变。</li>
<li>常量使用 <code>const</code> 关键字而不是 <code>let</code>，并且 必须 注明值的类型。</li>
<li>常量可以在任何作用域中声明，包括全局作用域，这在一个值需要被很多部分的代码用到时很有用。</li>
<li>常量只能被设置为常量表达式，而不可以是其他任何只能在运行时计算出的值。</li>
</ol>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">THREE_HOURS_IN_SECONDS</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<blockquote>
<p>Rust 对常量的命名约定是在单词之间使用全大写加下划线</p>
</blockquote>
<p>有关声明常量时可以使用哪些操作的详细信息，请参阅 <a href="https://doc.rust-lang.org/reference/const_eval.html">Rust Reference 的常量求值部分</a>。</p>
<h3 id="_4">隐藏</h3>
<p>可以定义一个与之前变量同名的新变量。称之为第一个变量被第二个 <strong>隐藏</strong>（Shadowing）了,
这意味着在使用变量的名称时，编译器将看到第二个变量。
实际上，第二个变量“遮蔽”了第一个变量，此时任何使用该变量名的行为中都会视为是在使用第二个变量，直到第二个变量自己也被隐藏或第二个变量的作用域结束。
可以用相同变量名称来隐藏一个变量，以及重复使用 let 关键字来多次隐藏，如下所示：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">  </span><span class="c1">// 首先将 x 绑定到值 5 上</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 接着通过 let x = 创建了一个新变量 x，获取初始值并加 1，这样 x 的值就变成 6 了</span>

<span class="w">    </span><span class="p">{</span><span class="w">       </span><span class="c1">// 然后，在使用花括号创建的内部作用域内</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">  </span><span class="c1">// 第三个 let 语句也隐藏了 x 并创建了一个新的变量，将之前的值乘以 2，x 得到的值是 12</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The value of x in the inner scope is: {x}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w">       </span>
<span class="w">    </span><span class="c1">// 当该作用域结束时，内部 shadowing 的作用域也结束了，x 又返回到 6</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The value of x is: {x}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>隐藏与将变量标记为 <code>mut</code> 是有区别的。当不小心尝试对变量重新赋值时，如果没有使用 <code>let</code> 关键字，就会导致编译时错误。
通过使用 let，我们可以用这个值进行一些计算，不过计算完之后变量仍然是不可变的。</p>
<p><code>mut</code> 与隐藏的另一个区别是，当再次使用 <code>let</code> 时，实际上创建了一个新变量，我们可以改变值的类型，并且复用这个名字。
例如，假设程序请求用户输入空格字符来说明希望在文本之间显示多少个空格，接下来我们想将输入存储成数字（多少个空格）：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">spaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;   &quot;</span><span class="p">;</span><span class="w">             </span><span class="c1">// 第一个 spaces 变量是字符串类型</span>
<span class="kd">let</span><span class="w"> </span><span class="n">spaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spaces</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">      </span><span class="c1">// 第二个 spaces 变量是数字类型</span>
</code></pre></div>
<p>隐藏使我们不必使用不同的名字，如 spaces_str 和 spaces_num；</p>
<p>相反，我们可以复用 spaces 这个更简单的名字。然而，如果尝试使用 <code>mut</code>，将会得到一个编译时错误，如下所示：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">spaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;   &quot;</span><span class="p">;</span><span class="w">  </span><span class="c1">// string类型</span>
<span class="n">spaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spaces</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">   </span><span class="c1">// int 类型</span>
</code></pre></div>
<p>错误提示:</p>
<div class="highlight"><pre><span></span><code><span class="cp">$</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="n">run</span><span class="w"></span>
<span class="w">   </span><span class="n">Compiling</span><span class="w"> </span><span class="n">variables</span><span class="w"> </span><span class="n">v0</span><span class="p">.</span><span class="mf">1.0</span><span class="w"> </span><span class="p">(</span><span class="n">file</span>:<span class="sd">///projects/variables)</span>
<span class="n">error</span><span class="p">[</span><span class="n">E0308</span><span class="p">]</span>: <span class="nc">mismatched</span><span class="w"> </span><span class="n">types</span><span class="w"></span>
<span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">3</span>:<span class="mi">14</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w"></span>
<span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">spaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;   &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w">                      </span><span class="o">-----</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="n">due</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">spaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spaces</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="o">|</span><span class="w">              </span><span class="o">^^^^^^^^^^^^</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="err">`</span><span class="o">&amp;</span><span class="kt">str</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="err">`</span><span class="kt">usize</span><span class="err">`</span><span class="w">  </span>

<span class="n">For</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">information</span><span class="w"> </span><span class="n">about</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">error</span><span class="p">,</span><span class="w"> </span><span class="kr">try</span><span class="w"> </span><span class="err">`</span><span class="n">rustc</span><span class="w"> </span><span class="o">--</span><span class="n">explain</span><span class="w"> </span><span class="n">E0308</span><span class="err">`</span><span class="p">.</span><span class="w"></span>
<span class="n">error</span>: <span class="nc">could</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">compile</span><span class="w"> </span><span class="err">`</span><span class="n">variables</span><span class="err">`</span><span class="w"> </span><span class="n">due</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="n">error</span><span class="w"></span>
</code></pre></div>
<blockquote>
<p>不能改变变量的类型</p>
</blockquote>
<h2 id="_5">数据类型</h2>
<p>在 Rust 中，每一个值都属于某一个 数据类型（data type），这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。
我们将看到两类数据类型子集：<strong>标量</strong>（scalar）和 <strong>复合</strong>（compound）。</p>
<blockquote>
<p><strong>Rust 是 静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。</strong></p>
</blockquote>
<p>使用 <code>parse</code> 将 <code>String</code> 转换为数字时，必须增加类型注解，像这样：</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">guess</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="s">&quot;42&quot;</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Not a number!&quot;</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<p>如果不像上面这样添加类型注解 : u32，Rust 会显示如下错误，这说明编译器需要我们提供更多信息，来了解我们想要的类型：</p>
<div class="highlight"><pre><span></span><code>$ cargo build
   Compiling no_type_annotations v0.1.0 <span class="o">(</span>file:///projects/no_type_annotations<span class="o">)</span>
error<span class="o">[</span>E0282<span class="o">]</span>: <span class="nb">type</span> annotations needed
 --&gt; src/main.rs:2:9
  <span class="p">|</span>
<span class="m">2</span> <span class="p">|</span>     <span class="nb">let</span> <span class="nv">guess</span> <span class="o">=</span> <span class="s2">&quot;42&quot;</span>.parse<span class="o">()</span>.expect<span class="o">(</span><span class="s2">&quot;Not a number!&quot;</span><span class="o">)</span><span class="p">;</span>
  <span class="p">|</span>         ^^^^^ consider giving <span class="sb">`</span>guess<span class="sb">`</span> a <span class="nb">type</span>

For more information about this error, try <span class="sb">`</span>rustc --explain E0282<span class="sb">`</span>.
error: could not compile <span class="sb">`</span>no_type_annotations<span class="sb">`</span> due to previous error
</code></pre></div>
<h3 id="_6">标量类型</h3>
<p><strong>标量</strong>（scalar）类型代表一个单独的值。Rust 有四种基本的标量类型：<strong>整型</strong>、<strong>浮点型</strong>、<strong>布尔类型</strong>和<strong>字符类型</strong>。</p>
<h4 id="_7">整型</h4>
<p><strong>整数</strong> 是一个没有小数部分的数字。</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64-bit</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>128-bit</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody>
</table>
<p><code>isize</code> 和 <code>usize</code> 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。</p>
<p>可以使用下面表格中的任何一种形式编写数字字面值。</p>
<p>请注意可以是多种数字类型的数字字面值允许使用类型后缀，例如 <strong>57u8</strong> 来指定类型，同时也允许使用 <code>_</code> 做为分隔符以方便读数，例如<code>1_000</code>，它的值与你指定的 <code>1000</code> 相同。</p>
<table>
<thead>
<tr>
<th>数字字面值</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Decimal (十进制)</td>
<td>98_222</td>
</tr>
<tr>
<td>Hex (十六进制)</td>
<td>0xff</td>
</tr>
<tr>
<td>Octal (八进制)</td>
<td>0o77</td>
</tr>
<tr>
<td>Binary (二进制)</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>Byte (单字节字符)(仅限于u8)</td>
<td>b'A'</td>
</tr>
</tbody>
</table>
<p>Rust 的默认类型通常是个不错的起点，数字类型默认是 <code>i32</code>。<code>isize</code> 或 <code>usize</code> 主要作为某些集合的索引。</p>
<p>其他 参考: <a href="https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html#%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA">整形溢出</a></p>
<h4 id="_8">浮点型</h4>
<p>Rust 也有两个原生的 浮点数（floating-point numbers）类型，它们是带小数点的数字。Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位。默认类型是 f64，因为在现代 CPU 中，它与 f32 速度几乎一样，不过精度更高。所有的浮点型都是有符号的。</p>
<p>这是一个展示浮点数的实例：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// f64</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span>: <span class="kt">f32</span> <span class="o">=</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// f32</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<blockquote>
<p>浮点数采用 IEEE-754 标准表示。f32 是单精度浮点数，f64 是双精度浮点数。</p>
</blockquote>
<h4 id="_9">数值运算</h4>
<p>Rust 中的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取余。整数除法会向下舍入到最接近的整数。下面的代码展示了如何在 let 语句中使用它们：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 加法</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 减法</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">difference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">95.5</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">4.3</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 乘法</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">product</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 除法</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">quotient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">56.7</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">32.2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">floored</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// 结果为0</span>

<span class="w">    </span><span class="c1">// 取余</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">remainder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">43</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>这些语句中的每个表达式使用了一个数学运算符并计算出了一个值，然后绑定给一个变量。<a href="https://kaisery.github.io/trpl-zh-cn/appendix-02-operators.html">附录 B</a> 包含 Rust 提供的所有运算符的列表。</p>
<h4 id="_10">布尔型</h4>
<p>正如其他大部分编程语言一样，Rust 中的布尔类型有两个可能的值：true 和 false。Rust 中的布尔类型使用 bool 表示。例如：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span>: <span class="kt">bool</span> <span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// with explicit type annotation</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="_11">字符类型</h4>
<p>Rust的 char 类型是语言中最原生的字母类型。下面是一些声明 char 值的例子：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;z&#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">z</span>: <span class="kt">char</span> <span class="o">=</span><span class="w"> </span><span class="sc">&#39;ℤ&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// with explicit type annotation</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">heart_eyed_cat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;😻&#39;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>注意，这里用单引号声明 <code>char</code> 字面量，而与之相反的是，使用<strong>双引号</strong>声明字符串字面量。Rust 的 <code>char</code> 类型的大小为四个字节(four bytes)，并代表了一个 <code>Unicode</code> 标量值（Unicode Scalar Value），这意味着它可以比 <code>ASCII</code> 表示更多内容。
在 Rust 中，带变音符号的字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值。
<code>Unicode</code> 标量值包含从 <strong>U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF 在内的值</strong>。
不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 char 并不符合。
第八章的 “<a href="https://kaisery.github.io/trpl-zh-cn/ch08-02-strings.html#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8-utf-8-%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%87%E6%9C%AC">使用字符串存储 UTF-8 编码的文本</a>” 中将详细讨论这个主题。</p>
<h3 id="_12">复合类型</h3>
<p><strong>复合类型</strong>（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：<strong>元组</strong>（tuple）和<strong>数组</strong>（array）。</p>
<h4 id="_13">元组类型</h4>
<p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。</p>
<p><strong>元组长度固定：一旦声明，其长度不会增大或缩小。</strong></p>
<p>使用包含在圆括号中的逗号分隔的值列表来创建一个元组。
元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。这个例子中使用了可选的类型注解：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tup</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">500</span><span class="p">,</span><span class="w"> </span><span class="mf">6.4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>tup 变量绑定到整个元组上，因为元组是一个单独的复合元素。
为了从元组中获取单个值，可以使用<strong>模式匹配</strong>（pattern matching）来<strong>解构</strong>（destructure）元组值，像这样：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">500</span><span class="p">,</span><span class="w"> </span><span class="mf">6.4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">   </span>
<span class="w">        </span><span class="c1">// 程序首先创建了一个元组并绑定到 tup 变量上</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tup</span><span class="p">;</span><span class="w">   </span>
<span class="w">        </span><span class="c1">// 接着使用了 let 和一个模式将 tup 分成了三个不同的变量，x、y 和 z。</span>
<span class="w">        </span><span class="c1">// 这叫做 解构（destructuring）因为它将一个元组拆成了三个部分。</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The value of y is: {y}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 最后，程序打印出了 y 的值，也就是 6.4。</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>也可以使用点号（.）后跟值的索引来直接访问它们。例如：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">500</span><span class="p">,</span><span class="w"> </span><span class="mf">6.4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">five_hundred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">six_point_four</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>不带任何值的元组有个特殊的名称，叫做 <strong>单元</strong>（unit） 元组。这种值以及对应的类型都写作 <code>()</code>，<strong>表示空值或空的返回类型</strong>。如果表达式不返回任何其他值，则会隐式返回单元值。</p>
<h4 id="_14">数组类型</h4>
<p>另一个包含多个值的方式是 <strong>数组</strong>（array）。与元组不同，<strong>数组中的每个元素的类型必须相同</strong>。Rust 中的数组与一些其他语言中的数组不同，<strong>Rust中的数组长度是固定的</strong>。</p>
<p>将数组的值写成在方括号内，用逗号分隔：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>当你想要在<strong>栈</strong>（stack）而不是在<strong>堆</strong>（heap）上为数据分配空间，或者是想要确保总是有固定数量的元素时，数组非常有用。
但是数组并不如 <code>vector</code> 类型灵活。<code>vector</code> 类型是标准库提供的一个 允许 增长和缩小长度的类似数组的集合类型。
当不确定是应该使用数组还是 <code>vector</code> 的时候，那么很可能应该使用 <code>vector</code>。<a href="https://kaisery.github.io/trpl-zh-cn/ch08-01-vectors.html">第八章</a>会详细讨论 <code>vector</code>。</p>
<p>然而，当你确定元素个数不会改变时，数组会更有用。例如，当你在一个程序中使用月份名字时，你更应趋向于使用数组而不是 vector，因为你确定只会有12个元素。</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">months</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;January&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;February&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;March&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;April&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;May&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;June&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;July&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="s">&quot;August&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;September&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;October&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;November&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;December&quot;</span><span class="p">];</span><span class="w"></span>
</code></pre></div>
<p>可以像这样编写数组的类型：在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="c1">// i32 是每个元素的类型。分号之后，数字 5 表明该数组包含五个元素。</span>

<span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="c1">// 通过在方括号中指定初始值加分号再加元素个数的方式来创建一个每个元素都为相同值的数组：</span>
<span class="c1">// 变量名为 a 的数组将包含 5 个元素，这些元素的值最初都将被设置为 3。</span>
<span class="c1">// 这种写法与 let a = [3, 3, 3, 3, 3]; 效果相同，但更简洁。</span>
</code></pre></div>
<h5 id="_15">访问数组元素</h5>
<p>数组是可以在栈(stack)上分配的已知固定大小的单个内存块。可以使用索引来访问数组的元素，像这样：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h5 id="_16">数组越界访问</h5>
<p>让我们看看如果我们访问数组结尾之后的元素会发生什么呢？比如你执行以下代码，它使用类似于第 2 章中的猜数字游戏的代码从用户那里获取数组索引：</p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;请输入数组索引&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">io</span>::<span class="n">stdin</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;读取数据失败&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">trim</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">parse</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;请输入数字&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;数组中索引为 {index} 的值时: {element}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>此代码编译成功。如果您使用 <code>cargo run</code> 运行此代码并输入 0、1、2、3 或 4，程序将在数组中的索引处打印出相应的值。如果你输入一个超过数组末端的数字，如 10，你会看到这样的输出：</p>
<div class="highlight"><pre><span></span><code>thread <span class="s1">&#39;main&#39;</span> panicked at <span class="s1">&#39;index out of bounds: the len is 5 but the index is 10&#39;</span>, src/main.rs:19:19
note: run with <span class="sb">`</span><span class="nv">RUST_BACKTRACE</span><span class="o">=</span><span class="m">1</span><span class="sb">`</span> environment variable to display a backtrace
</code></pre></div>
<p>程序在索引操作中使用一个无效的值时导致 运行时 错误。
程序带着错误信息退出，并且没有执行最后的 println! 语句。
当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。
如果索引超出了数组长度，Rust 会 panic，这是 Rust 术语，<strong>它用于程序因为错误而退出的情况</strong>。
这种检查必须在运行时进行，特别是在这种情况下，因为编译器不可能知道用户在以后运行代码时将输入什么值。</p>
<p>这是第一个在实战中遇到的 Rust 安全原则的例子。
在很多底层语言中，并没有进行这类检查，这样当提供了一个不正确的索引时，就会访问无效的内存。
通过立即退出而不是允许内存访问并继续执行，Rust 让你避开此类错误。
<a href="https://kaisery.github.io/trpl-zh-cn/ch09-00-error-handling.html">第九章</a>会更详细地讨论 Rust 的错误处理机制，以及如何编写可读性强而又安全的代码，使程序既不会 panic 也不会导致非法内存访问。</p>
<h2 id="_17">函数</h2>
<p>函数在 Rust 代码中非常普遍。你已经见过语言中最重要的函数之一：<code>main</code> 函数，它是很多程序的入口点。你也见过 <code>fn</code> 关键字，它用来声明新函数。</p>
<p>Rust 代码中的函数和变量名使用 <code>snake case</code> 规范风格。在 <code>snake case</code> 中，<strong>所有字母都是小写并使用下划线分隔单词</strong>。这是一个包含函数定义示例的程序：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">another_function</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 通过输入 fn 后面跟着函数名和一对圆括号来定义函数。大括号告诉编译器哪里是函数体的开始和结尾。</span>
<span class="k">fn</span> <span class="nf">another_function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Another function.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// main 函数中的代码会按顺序执行。首先，打印 “Hello, world!” 信息，然后调用 another_function 函数并打印它的信息。</span>
</code></pre></div>
<p>可以使用函数名后跟圆括号来调用我们定义过的任意函数。
因为程序中已定义 another_function 函数，所以可以在 main 函数中调用它。注意，
<ins class="critic">源码中 another_function 定义在 main 函数 之后；也可以定义在之前</ins>。
<mark class="critic">Rust 不关心函数定义所在的位置，只要函数被调用时出现在调用之处可见的作用域内就行。</mark></p>
<h3 id="_18">参数</h3>
<p>我们可以定义为拥有 <strong>参数</strong>（parameters）的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。
技术上讲，这些具体值被称为参数（arguments），但是在日常交流中，人们倾向于不区分使用 parameter 和 argument 来表示函数定义中的变量或调用函数时传入的具体值。</p>
<p>在这版 <strong>another_function</strong> 中，我们增加了一个参数：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">another_function</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 我们将 5 传给 another_function 时，</span>
<span class="w">    </span><span class="c1">// println! 宏会把 5 放在格式字符串中包含 x 的那对花括号的位置。</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// another_function 的声明中有一个命名为 x 的参数。</span>
<span class="c1">// x 的类型被指定为 i32。</span>
<span class="k">fn</span> <span class="nf">another_function</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The value of x is: {x}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><mark class="critic">在函数签名中，<strong>必须</strong> 声明每个参数的类型。</mark>
这是 Rust 设计中一个经过慎重考虑的决定：<mark class="critic">要求在函数定义中提供类型注解</mark>，意味着编译器再也不需要你在代码的其他地方注明类型来指出你的意图。
而且，在知道函数需要什么类型后，编译器就能够给出更有用的错误消息。</p>
<p>当定义多个参数时，使用逗号分隔，像这样：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">print_labeled_measurement</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;h&#39;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 它有两个参数。第一个参数名为 value， 类型是 i32。</span>
<span class="c1">// 第二个参数是 unit_label ，类型是 char。</span>
<span class="k">fn</span> <span class="nf">print_labeled_measurement</span><span class="p">(</span><span class="n">value</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">unit_label</span>: <span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The measurement is: {value}{unit_label}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="_19">语句和表达式</h3>
<p><mark class="critic">函数体由一系列的<strong>语句</strong>和一个可选的<strong>结尾表达式</strong>构成。</mark>
目前为止，我们提到的函数还不包含结尾表达式，不过你已经见过作为语句一部分的表达式。
因为 Rust 是一门基于<strong>表达式</strong>（expression-based）的语言，这是一个需要理解的（不同于其他语言）重要区别。
其他语言并没有这样的区别，所以让我们看看语句与表达式有什么区别以及这些区别是如何影响函数体的。</p>
<p><ins class="critic"><strong>语句</strong>（Statements）是执行一些操作但不返回值的指令</ins>。
<ins class="critic"><strong>表达式</strong>（Expressions）计算并产生一个值。</ins> 让我们看一些例子。</p>
<p>实际上，我们已经使用过语句和表达式。使用 let 关键字创建变量并绑定一个值是一个语句。在下面示例 中，<code>let y = 6;</code> 是一个语句。</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// 函数定义也是语句，上面整个例子本身就是一个语句。</span>
</code></pre></div>
<p>语句不返回值。因此，不能把 let 语句赋值给另一个变量，比如下面的例子尝试做的，会产生一个错误：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>当运行这个程序时，会得到如下错误：</p>
<div class="highlight"><pre><span></span><code>$ cargo run
   Compiling functions v0.1.0 <span class="o">(</span>file:///projects/functions<span class="o">)</span>
error: expected expression, found statement <span class="o">(</span><span class="sb">`</span><span class="nb">let</span><span class="sb">`</span><span class="o">)</span>
 --&gt; src/main.rs:2:14
  <span class="p">|</span>
<span class="m">2</span> <span class="p">|</span>     <span class="nb">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="o">(</span><span class="nb">let</span> <span class="nv">y</span> <span class="o">=</span> <span class="m">6</span><span class="o">)</span><span class="p">;</span>
  <span class="p">|</span>              ^^^^^^^^^
  <span class="p">|</span>
  <span class="o">=</span> note: variable declaration using <span class="sb">`</span><span class="nb">let</span><span class="sb">`</span> is a statement

error<span class="o">[</span>E0658<span class="o">]</span>: <span class="sb">`</span><span class="nb">let</span><span class="sb">`</span> expressions <span class="k">in</span> this position are unstable
 --&gt; src/main.rs:2:14
  <span class="p">|</span>
<span class="m">2</span> <span class="p">|</span>     <span class="nb">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="o">(</span><span class="nb">let</span> <span class="nv">y</span> <span class="o">=</span> <span class="m">6</span><span class="o">)</span><span class="p">;</span>
  <span class="p">|</span>              ^^^^^^^^^
  <span class="p">|</span>
  <span class="o">=</span> note: see issue <span class="c1">#53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information</span>

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  <span class="p">|</span>
<span class="m">2</span> <span class="p">|</span>     <span class="nb">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="o">(</span><span class="nb">let</span> <span class="nv">y</span> <span class="o">=</span> <span class="m">6</span><span class="o">)</span><span class="p">;</span>
  <span class="p">|</span>             ^         ^
  <span class="p">|</span>
  <span class="o">=</span> note: <span class="sb">`</span><span class="c1">#[warn(unused_parens)]` on by default</span>
help: remove these parentheses
  <span class="p">|</span>
<span class="m">2</span> -     <span class="nb">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="o">(</span><span class="nb">let</span> <span class="nv">y</span> <span class="o">=</span> <span class="m">6</span><span class="o">)</span><span class="p">;</span>
<span class="m">2</span> +     <span class="nb">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="nb">let</span> <span class="nv">y</span> <span class="o">=</span> <span class="m">6</span><span class="p">;</span>
  <span class="p">|</span> 

For more information about this error, try <span class="sb">`</span>rustc --explain E0658<span class="sb">`</span>.
warning: <span class="sb">`</span>functions<span class="sb">`</span> <span class="o">(</span>bin <span class="s2">&quot;functions&quot;</span><span class="o">)</span> generated <span class="m">1</span> warning
error: could not compile <span class="sb">`</span>functions<span class="sb">`</span> due to <span class="m">2</span> previous errors<span class="p">;</span> <span class="m">1</span> warning emitted
</code></pre></div>
<p>let y = 6 语句并不返回值，所以没有可以绑定到 x 上的值。
这与其他语言不同，例如 C 和 Ruby，它们的赋值语句会返回所赋的值。
在这些语言中，可以这么写 x = y = 6，这样 x 和 y 的值都是 6；Rust 中不能这样写。</p>
<p>表达式会计算出一个值，并且你将编写的大部分 Rust 代码是由表达式组成的。
考虑一个数学运算，比如 5 + 6，这是一个表达式并计算出值 11。
表达式可以是语句的一部分：在上面中，语句 <code>let y = 6;</code> 中的 6 是一个表达式，它计算出的值是 6。
<strong>函数调用是一个表达式</strong>。<strong>宏调用是一个表达式</strong>。<strong>用大括号创建的一个新的块作用域也是一个表达式</strong>，例如：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 是一个代码块，它的值是 4</span>
<span class="w">        </span><span class="c1">// 这个值作为 let 语句的一部分被绑定到 y 上。</span>
<span class="w">        </span><span class="c1">// 注意 x+1 这一行在结尾没有分号，与你见过的大部分代码行不同。</span>
<span class="w">        </span><span class="c1">// 表达式的结尾没有分号。</span>
<span class="w">        </span><span class="c1">// 如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。</span>
<span class="w">        </span><span class="c1">// 在接下来探索具有返回值的函数和表达式时要谨记这一点。</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The value of y is: {y}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="_20">具有返回值的函数</h3>
<p>函数可以向调用它的代码返回值。我们<ins class="critic">并不对返回值命名，但要在箭头（-&gt;）后声明它的类型</ins>。
在 Rust 中，<strong>函数的返回值等同于函数体最后一个表达式的值</strong>。
使用 <code>return</code> 关键字和指定值，可从函数中提前返回；
但大部分函数隐式的返回最后的表达式。
这是一个有返回值的函数的例子：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 在 five 函数中没有函数调用、宏、甚至没有 let 语句 —— 只有数字 5。</span>
<span class="c1">// 这在 Rust 中是一个完全有效的函数。</span>
<span class="c1">// 注意，也指定了函数返回值的类型，就是 -&gt; i32。</span>
<span class="k">fn</span> <span class="nf">five</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="mi">5</span><span class="w"></span>
<span class="w">    </span><span class="c1">// five 函数没有参数并定义了返回值类型，不过函数体只有单单一个 5 也没有分号，因为这是一个表达式，我们想要返回它的值。</span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 这一行表明我们使用函数的返回值初始化一个变量。</span>
<span class="w">    </span><span class="c1">// 因为 five 函数返回 5，这一行与代码 let x = 5; 相同</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">five</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The value of x is: {x}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>让我们看看另一个例子：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plus_one</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The value of x is: {x}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">plus_one</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 如果在包含 x + 1 的行尾加上一个分号，把它从表达式变成语句，我们将看到一个错误。</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="_21">注释</h2>
<p>程序员在源码中留下 <strong>注释</strong>（comments），编译器会忽略它们，不过阅读代码的人可能觉得有用。</p>
<h3 id="_22">单行注释</h3>
<p>惯用的注释样式是以两个斜杠开始注释，并持续到本行的结尾。对于超过一行的注释，需要在每一行前都加上 <code>//</code></p>
<div class="highlight"><pre><span></span><code><span class="c1">// So we’re doing something complicated here, long enough that we need</span>
<span class="c1">// multiple lines of comments to do it! Whew! Hopefully, this comment will</span>
<span class="c1">// explain what’s going on.</span>
</code></pre></div>
<p>注释也可以放在包含代码的行的末尾：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">lucky_number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w"> </span><span class="c1">// I’m feeling lucky today</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="_23">文档注释</h3>
<h2 id="_24">控制流</h2>
<p>根据条件是否为真来决定是否执行某些代码，以及根据条件是否为真来重复运行一段代码的能力是大部分编程语言的基本组成部分。</p>
<h3 id="if">if表达式</h3>
<p><strong><code>if</code> 表达式允许根据条件执行不同的代码分支。</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 所有的 if 表达式都以 if 关键字开头，其后跟一个条件。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 在条件为真时希望执行的代码块位于紧跟条件之后的大括号中。</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;condition was true&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 一个可选的 else 表达式来提供一个在条件为假时应当执行的代码块</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;condition was false&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><mark class="critic">值得注意的是代码中的条件 <strong>必须</strong> 是 bool 值。如果条件不是 bool 值，我们将得到一个错误。</mark></p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 会报，expected `bool`, found integer 错误。</span>
<span class="w">    </span><span class="c1">// Rust 并不会尝试自动地将非布尔值转换为布尔值。</span>
<span class="w">    </span><span class="c1">// 必须总是显式地使用布尔值作为 if 的条件。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;number was three&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="else-if">else if 表达式</h3>
<p>可以将 else if 表达式与 if 和 else 组合来实现多重条件。</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 按顺序检查每个 if 表达式并执行第一个条件为真的代码块。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;number is divisible by 4&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;number is divisible by 3&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;number is divisible by 2&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;number is not divisible by 4, 3, or 2&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Rust 只会执行第一个条件为真的代码块，并且一旦它找到一个以后，甚至都不会检查剩下的条件了。</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>使用过多的 <code>else if</code> 表达式会使代码显得杂乱无章，所以如果有多于一个 <code>else if</code> 表达式，最好重构代码。
为此，第六章会介绍一个强大的 Rust 分支结构（branching construct），叫做 <code>match</code>。</p>
<h3 id="letif">let中的if</h3>
<p>因为 if 是一个表达式，可以在 let 语句的右侧使用它，</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 将 if 表达式的返回值赋给一个变量</span>
<span class="w">    </span><span class="c1">// 代码块的值是其最后一个表达式的值，而数字本身就是一个表达式。</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The value of number is: {number}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>类型需统一</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;six&quot;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 类型不统一，会报错，expected integer, found `&amp;str`</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The value of number is: {number}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h3 id="_25">循环表达式</h3>
<p><strong>多次执行同一段代码是很常用的，Rust 为此提供了多种 循环（loops）。</strong></p>
<h4 id="loop">loop 循环</h4>
<p>loop 关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止。</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 会看到连续的反复打印 again!，直到我们手动停止程序。</span>
<span class="w">        </span><span class="c1">// 大部分终端都支持一个快捷键，ctrl-c，来终止一个陷入无限循环的程序。</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;again!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li><code>break</code> 关键字来告诉程序何时停止循环。</li>
<li><code>continue</code> 关键字告诉程序跳过这个循环迭代中的任何剩余代码，并转到下一个迭代。</li>
</ul>
<h5 id="_26">从循环返回值</h5>
<p>loop 的一个用例是重试可能会失败的操作，比如检查线程是否完成了任务。然而你可能会需要将操作的结果传递给其它的代码。如果将返回值加入你用来停止循环的 break 表达式，它会被停止的循环返回：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 一个名为 counter 的变量并初始化为 0</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 接着声明了一个名为 result 来存放循环的返回值。</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 在循环的每一次迭代中，我们将 counter 变量加 1</span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// 接着检查计数是否等于 10。</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// 使用 break 关键字返回值 counter * 2</span>
<span class="w">            </span><span class="k">break</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="c1">// 通过分号结束赋值给 result 的语句。</span>

<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 最后打印出 result 的值，也就是 20。</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;The result is {result}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h5 id="_27">循环标签</h5>
<p>如果存在嵌套循环，<code>break</code> 和 <code>continue</code> 应用于此时最内层的循环。你可以选择在一个循环上指定一个 <strong>循环标签</strong>（loop label），然后将标签与 <code>break</code> 或 <code>continue</code> 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环。</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 外层循环有一个标签 counting_up</span>
<span class="w">    </span><span class="o">&#39;</span><span class="na">counting_up</span>: <span class="nc">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;count = {count}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// 没有标签的内部循环从 10 向下数到 9。</span>
<span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;remaining = {remaining}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">remaining</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="c1">// 没有指定标签的 break 将只退出内层循环。</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="c1">// break &#39;counting_up; 语句将退出外层循环。</span>
<span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="nl">&#39;counting_up</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">remaining</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;End count = {count}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="while">while 循环</h4>
<p>当条件为真，执行循环。当条件不再为真，调用 break 停止循环。</p>
<p>比如：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// 当条件为真时，使用 while 循环运行代码</span>
<span class="w">    </span><span class="c1">// 这种结构消除了很多使用 loop、if、else 和 break 时所必须的嵌套，这样更加清晰。</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{number}!&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">number</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;LIFTOFF!!!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h4 id="for">for 循环</h4>
<p>可以使用 for 循环来对一个集合的每个元素执行一些代码。</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;the value is: {element}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p><mark class="critic">for 循环的安全性和简洁性使得它成为 Rust 中在用于遍历数组时是使用最多的循环结构。</mark></p>
<p>另一个例子：</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 遍历标准库提供的类型Range类型</span>
<span class="w">    </span><span class="c1">// 用来生成从一个数字开始到另一个数字之前结束的所有数字的序列。</span>
<span class="w">    </span><span class="c1">// rev，用来反转 range</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">).</span><span class="n">rev</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{number}!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;LIFTOFF!!!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="页脚" >
      
        
        <a href="../guessing-game/" class="md-footer__link md-footer__link--prev" aria-label="上一页: 猜数游戏" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                上一页
              </span>
              猜数游戏
            </div>
          </div>
        </a>
      
      
        
        <a href="../ownership/" class="md-footer__link md-footer__link--next" aria-label="下一页: 所有权" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                下一页
              </span>
              所有权
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.16e2a7d4.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../assets/javascripts/bundle.5a2dcb6a.min.js"></script>
      
    
    
  </body>
</html>